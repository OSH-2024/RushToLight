#### Rust编译
##### Rust编译器的使用
Rust前端编译器为rustc,把rust源代码变为中间表示（MIR），后端编译器为LLVM，把MIR变为机器码。
+ Linux下:
  用以下命令安装rustup,内含rustc编译器。
  ``` 
  $ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
  ```
    编写main.rs程序：
    ``` rust
    fn main() {
        println!("Hello, world!");
    }
    ```

    编译main.rs(为main):
    ```
    $ rustc main.rs
    ```
    运行：
    ```
    $ ./main
    Hello, world!
    ```
    + cargo 的使用：
        Cargo 是 Rust 的构建系统和包管理器。可以构建代码、下载依赖库并编译这些库。
        假设准备在一个hello目录中构建项目,用以下命令：
        ```
        $ cargo new hello
        ```
        则hello文件中会出现一个Cargo.toml文件，一个src目录，src目录里有main.rs文件，内容默认为一段打印```Hello, world!```的代码。可把main.rs改为自己的代码。进入```hello```目录执行：
        ```
        $ cargo run
        ```
        会在hello下编译、自动生成项目，并运行生成的```target/debug```下的hello文件。

        （```cargo build```命令构建项目但不运行程序，```cargo check```快速检查代码确保其可以编译，但并不产生可执行文件）

##### Rust与C混合编程
###### Rust调用C
在项目中构建C依赖库或在操作系统中寻找指定的 C 依赖库可以通过构建脚本实现。构建脚本即在项目的根目录下添加一个```build.rs```文件,Cargo会先编译和执行该构建脚本然后再去构建整个项目。
```build.rs```如下：
```rust
  fn main() {
        // 表示在hello/hello.c文件发生修改的时候需要重新运行build脚本
        println!("cargo:rerun-if-changed=hello/hello.c");

        let mut builder: cc::Build = cc::Build::new();
        builder
            .file("./hello/hello.c")
            .compile("hello");
    }
```
在根目录下建立```hello/hello.c```,```hello.c```如下 ：
``` cpp
#include <stdio.h>

void hello() {
    printf("Hello, build script!!!!\n");
}
```
修改```Cargo.toml```,加上
```
[build-dependencies]
cc = "1.0"
```
```main.rs```为：
```rust
// 使用extern声明hello是C里面的函数
extern "C" {
    fn hello();
}

fn main() {
    // rust调用的时候需要使用unsafe包裹
    unsafe {
        hello();
    }
    println!("Hello, world!");
}
```
这样即可调用C库中的函数。

###### C调用Rust
首先建立一个rust库工程foo：
```
$ cargo new --lib foo
```
在lib.rs中加上
```rust
#[no_mangle]//表示生成的函数名经过编译后依然为foo，从而和c语言保持一致；
pub extern "C" fn foo(a: i32, b: i32) {//extern "C" 可以提供给其他库或者语言调用，并且采用c语言的调用约定。
    println!("hello : a + b = {}", a + b);
}
```
在```Cargo.toml```中加上
```
[lib]
crate-type = ["staticlib"]#编译成静态链接库
name = "foo"#库名称为foo
```
编译工程
```
$ cargo build
```
编译后，在./target/debug目录下生成一个libfoo.a静态库。
创建与foo平级的call_rust.c文件，并调用libfoo.a中导出的函数foo：
```cpp
extern void foo(int a, int b);

int main() {
    foo(5, 7);
    return 0;
}
```
编译为call_rust可执行文件：
```
gcc -o call_rust call_rust.c ./foo/target/debug/libfoo.a
```
```./call_rust```即可运行。
