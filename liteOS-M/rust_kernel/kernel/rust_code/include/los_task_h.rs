/* automatically generated by rust-bindgen 0.59.1 */
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const OS_LITTLE_ENDIAN: u32 = 4660;
pub const OS_BIG_ENDIAN: u32 = 17185;
pub const OS_BYTE_ORDER: u32 = 4660;
pub const LOS_OK: u32 = 0;
pub const OS_FAIL: u32 = 1;
pub const OS_64BIT_MAX: i32 = -1;
pub const __LIBATOMIC_N_LOCKS: u32 = 16;
pub const OS_SYS_CLOCK: u32 = 1000000;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND: u32 = 100;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND_MINI: u32 = 1000;
pub const LOSCFG_BASE_CORE_TICK_PERIOD_MS: u32 = 10;
pub const LOSCFG_BASE_CORE_TICK_WTIMER: u32 = 0;
pub const LOSCFG_BASE_CORE_TICK_RESPONSE_MAX: u32 = 0;
pub const LOSCFG_PLATFORM_HWI: u32 = 1;
pub const LOSCFG_USE_SYSTEM_DEFINED_INTERRUPT: u32 = 1;
pub const LOSCFG_PLATFORM_HWI_LIMIT: u32 = 32;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO: u32 = 10;
pub const LOSCFG_BASE_CORE_TSK_LIMIT: u32 = 5;
pub const LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE: u32 = 384;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE: u32 = 1024;
pub const LOSCFG_BASE_CORE_TIMESLICE: u32 = 1;
pub const LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT: u32 = 20000;
pub const LOSCFG_BASE_CORE_TSK_MONITOR: u32 = 0;
pub const LOSCFG_BASE_CORE_EXC_TSK_SWITCH: u32 = 0;
pub const LOS_TASK_PRIORITY_HIGHEST: u32 = 0;
pub const LOS_TASK_PRIORITY_LOWEST: u32 = 31;
pub const LOSCFG_BASE_CORE_TASKSTACK_INDEPENDENT: u32 = 0;
pub const LOSCFG_STACK_POINT_ALIGN_SIZE: u32 = 8;
pub const LOSCFG_BASE_IPC_SEM: u32 = 1;
pub const LOSCFG_BASE_IPC_SEM_LIMIT: u32 = 6;
pub const OS_SEM_COUNTING_MAX_COUNT: u32 = 65535;
pub const LOSCFG_BASE_IPC_MUX: u32 = 1;
pub const LOSCFG_BASE_IPC_MUX_LIMIT: u32 = 6;
pub const LOSCFG_BASE_IPC_QUEUE: u32 = 1;
pub const LOSCFG_BASE_IPC_QUEUE_LIMIT: u32 = 6;
pub const LOSCFG_BASE_IPC_STATIC_QUEUE_LIMIT: u32 = 3;
pub const LOSCFG_BASE_CORE_SWTMR: u32 = 1;
pub const LOSCFG_BASE_CORE_SWTMR_LIMIT: u32 = 5;
pub const LOSCFG_BASE_CORE_TSK_SWTMR_STACK_SIZE: u32 = 1024;
pub const LOSCFG_BASE_CORE_SWTMR_ALIGN: u32 = 0;
pub const OS_SWTMR_HANDLE_QUEUE_SIZE: u32 = 5;
pub const LOS_COMMON_DIVISOR: u32 = 10;
pub const LOSCFG_SYS_EXTERNAL_HEAP: u32 = 0;
pub const LOSCFG_SYS_HEAP_SIZE: u32 = 65536;
pub const LOSCFG_MEM_MUL_POOL: u32 = 1;
pub const LOSCFG_MEM_FREE_BY_TASKID: u32 = 0;
pub const LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK: u32 = 0;
pub const LOSCFG_MEM_OMIT_LR_CNT: u32 = 4;
pub const LOSCFG_MEM_RECORD_LR_CNT: u32 = 3;
pub const LOSCFG_MEM_LEAKCHECK_RECORD_MAX_NUM: u32 = 1024;
pub const LOSCFG_MEM_WATERLINE: u32 = 1;
pub const OS_SYS_MEM_NUM: u32 = 20;
pub const OS_SYS_NOCACHEMEM_SIZE: u32 = 0;
pub const LOSCFG_MEM_MUL_REGIONS: u32 = 0;
pub const LOSCFG_EXC_HARDWARE_STACK_PROTECTION: u32 = 0;
pub const CMSIS_OS_VER: u32 = 2;
pub const LOSCFG_KERNEL_PRINTF: u32 = 1;
pub const LOSCFG_MPU_ENABLE: u32 = 0;
pub const LOSCFG_TASK_MEM_USED: u32 = 0;
pub const LOSCFG_PLATFORM_HWI_WITH_ARG: u32 = 0;
pub const LOSCFG_ARCH_HWI_VECTOR_ALIGN: u32 = 256;
pub const LOSCFG_KERNEL_SIGNAL: u32 = 0;
pub const LOSCFG_KERNEL_PM: u32 = 0;
pub const LOSCFG_KERNEL_PM_IDLE: u32 = 0;
pub const LOSCFG_SHELL_STACK_SIZE: u32 = 4096;
pub const LOS_WAITMODE_AND: u32 = 4;
pub const LOS_WAITMODE_OR: u32 = 2;
pub const LOS_WAITMODE_CLR: u32 = 1;
pub const OS_ERR_MAGIC_WORD: u32 = 2712847352;
pub const TICK_CHECK: u32 = 67108864;
pub const CYCLE_CHECK: u32 = 4294967295;
pub const SHIFT_32_BIT: u32 = 32;
pub const MAX_HOUR: u32 = 24;
pub const MAX_MINUTES: u32 = 60;
pub const MAX_SECONDS: u32 = 60;
pub const MILSEC: u32 = 1000;
pub const RTC_WAKEUPCLOCK_RTCCLK: u32 = 32768;
pub const RTC_WAKEUPCLOCK_RTCCLK_DIV: u32 = 16;
pub const RTC_CALIBRATE_SLEEP_TIME: u32 = 8;
pub const MACHINE_CYCLE_DEALAY_TIMES: u32 = 400;
pub const OS_SYS_MS_PER_SECOND: u32 = 1000;
pub const OS_SYS_US_PER_SECOND: u32 = 1000000;
pub const OS_SYS_NS_PER_SECOND: u32 = 1000000000;
pub const OS_SYS_NS_PER_MS: u32 = 1000000;
pub const OS_SYS_NS_PER_US: u32 = 1000;
pub const OS_MS_PER_TICK: u32 = 10;
pub const OS_US_PER_TICK: u32 = 10000;
pub const OS_NS_PER_TICK: u32 = 10000000;
pub const OS_SYS_MV_32_BIT: u32 = 32;
pub const OS_SYS_US_PER_MS: u32 = 1000;
pub const OS_SYS_APPVER_NAME_MAX: u32 = 64;
pub const OS_SYS_MAGIC_WORD: u32 = 2863311530;
pub const OS_SYS_EMPTY_STACK: u32 = 3402287818;
pub const LOS_TASK_ATTR_JOINABLE: u32 = 2147483648;
pub const LOS_TASK_NAMELEN: u32 = 32;
pub const LOS_NO_WAIT: u32 = 0;
pub const LOS_WAIT_FOREVER: u32 = 4294967295;
pub const OS_TASK_ERRORID: u32 = 4294967295;
pub const OS_TASK_PRIORITY_HIGHEST: u32 = 0;
pub const OS_TASK_PRIORITY_LOWEST: u32 = 31;
pub const OS_TASK_STATUS_UNUSED: u32 = 1;
pub const OS_TASK_STATUS_SUSPEND: u32 = 2;
pub const OS_TASK_STATUS_READY: u32 = 4;
pub const OS_TASK_STATUS_PEND: u32 = 8;
pub const OS_TASK_STATUS_RUNNING: u32 = 16;
pub const OS_TASK_STATUS_DELAY: u32 = 32;
pub const OS_TASK_STATUS_TIMEOUT: u32 = 64;
pub const OS_TASK_STATUS_PEND_TIME: u32 = 128;
pub const OS_TASK_STATUS_EXIT: u32 = 256;
pub const OS_TASK_FLAG_STACK_FREE: u32 = 2048;
pub const OS_TASK_FLAG_SYSTEM_TASK: u32 = 4096;
pub const OS_TASK_FLAG_SIGNAL: u32 = 8192;
pub const OS_TASK_FLAG_FREEZE: u32 = 16384;
pub const OS_TASK_FLAG_JOINABLE: u32 = 32768;
pub const OS_TASK_STACK_SIZE_ALIGN: u32 = 16;
pub const OS_TASK_STACK_ADDR_ALIGN: u32 = 8;
pub const OS_TASK_MAGIC_WORD: u32 = 3435973836;
pub const OS_TASK_STACK_INIT: u32 = 3402287818;
pub const OS_TSK_PRINUM: u32 = 32;
pub const OS_TSK_SORTLINK_LEN: u32 = 32;
pub const OS_TSK_HIGH_BITS: u32 = 5;
pub const OS_TSK_LOW_BITS: u32 = 27;
pub const OS_TSK_MAX_ROLLNUM: u32 = 4294967263;
pub const OS_TSK_SORTLINK_LOGLEN: u32 = 5;
pub const OS_TSK_SORTLINK_MASK: u32 = 31;
pub const OS_TSK_HIGH_BITS_MASK: u32 = 4160749568;
pub const OS_TSK_LOW_BITS_MASK: i64 = -4160749569;
pub const OS_TASK_SWITCH_INFO_COUNT: u32 = 10;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type INT8 = ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type FLOAT = f32;
pub type DOUBLE = f64;
pub type CHAR = ::std::os::raw::c_char;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type INT64 = ::std::os::raw::c_longlong;
pub type UINTPTR = ::std::os::raw::c_uint;
pub type INTPTR = ::std::os::raw::c_int;
pub type Atomic = INT32;
pub type Atomic64 = INT64;
pub type BOOL = ::std::os::raw::c_uint;
extern "C" {
    pub static mut m_aucSysMem0: *mut UINT8;
}
pub type HWI_HANDLE_T = UINT32;
pub type HWI_PRIOR_T = UINT16;
pub type HWI_MODE_T = UINT16;
pub type HWI_ARG_T = UINT32;
pub type HWI_PROC_FUNC = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIrqParam {
    #[doc = "< The interrupt number"]
    pub swIrq: ::std::os::raw::c_int,
    #[doc = "< The pointer to the device ID that launches the interrupt"]
    pub pDevId: *mut ::std::os::raw::c_void,
    #[doc = "< The interrupt name"]
    pub pName: *const CHAR,
}
#[test]
fn bindgen_test_layout_tagIrqParam() {
    assert_eq!(
        ::std::mem::size_of::<tagIrqParam>(),
        24usize,
        concat!("Size of: ", stringify!(tagIrqParam))
    );
    assert_eq!(
        ::std::mem::align_of::<tagIrqParam>(),
        8usize,
        concat!("Alignment of ", stringify!(tagIrqParam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagIrqParam>())).swIrq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagIrqParam),
            "::",
            stringify!(swIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagIrqParam>())).pDevId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagIrqParam),
            "::",
            stringify!(pDevId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagIrqParam>())).pName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tagIrqParam),
            "::",
            stringify!(pName)
        )
    );
}
pub type HwiIrqParam = tagIrqParam;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HwiControllerOps {
    pub triggerIrq: ::std::option::Option<unsafe extern "C" fn(hwiNum: HWI_HANDLE_T) -> UINT32>,
    pub clearIrq: ::std::option::Option<unsafe extern "C" fn(hwiNum: HWI_HANDLE_T) -> UINT32>,
    pub enableIrq: ::std::option::Option<unsafe extern "C" fn(hwiNum: HWI_HANDLE_T) -> UINT32>,
    pub disableIrq: ::std::option::Option<unsafe extern "C" fn(hwiNum: HWI_HANDLE_T) -> UINT32>,
    pub setIrqPriority: ::std::option::Option<
        unsafe extern "C" fn(hwiNum: HWI_HANDLE_T, priority: UINT8) -> UINT32,
    >,
    pub getCurIrqNum: ::std::option::Option<unsafe extern "C" fn() -> UINT32>,
    pub createIrq: ::std::option::Option<
        unsafe extern "C" fn(hwiNum: HWI_HANDLE_T, hwiPrio: HWI_PRIOR_T) -> UINT32,
    >,
}
#[test]
fn bindgen_test_layout_HwiControllerOps() {
    assert_eq!(
        ::std::mem::size_of::<HwiControllerOps>(),
        56usize,
        concat!("Size of: ", stringify!(HwiControllerOps))
    );
    assert_eq!(
        ::std::mem::align_of::<HwiControllerOps>(),
        8usize,
        concat!("Alignment of ", stringify!(HwiControllerOps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).triggerIrq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(triggerIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).clearIrq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(clearIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).enableIrq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(enableIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).disableIrq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(disableIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).setIrqPriority as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(setIrqPriority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).getCurIrqNum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(getCurIrqNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).createIrq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(createIrq)
        )
    );
}
extern "C" {
    pub static mut __stack_chk_guard: UINT32;
}
extern "C" {
    pub fn __stack_chk_fail();
}
extern "C" {
    #[doc = " @ingroup  los_interrupt"]
    #[doc = " @brief Delete hardware interrupt."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to delete hardware interrupt."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The hardware interrupt module is usable only when the configuration item for hardware"]
    #[doc = " interrupt tailoring is enabled.</li>"]
    #[doc = " <li>Hardware interrupt number value range: [OS_USER_HWI_MIN,OS_USER_HWI_MAX]. The value range"]
    #[doc = " applicable for a Cortex-A7 platform is [32,95].</li>"]
    #[doc = " <li>OS_HWI_MAX_NUM specifies the maximum number of interrupts that can be created.</li>"]
    #[doc = " <li>Before executing an interrupt on a platform, refer to the chip manual of the platform.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  hwiNum   [IN] Type#HWI_HANDLE_T: hardware interrupt number. The value range applicable"]
    #[doc = "                       for a Cortex-A7 platform is [32,95]."]
    #[doc = " @param  irqParam [IN] Type #HwiIrqParam *. ID of hardware interrupt which will base on"]
    #[doc = "                                                when delete the hardware interrupt."]
    #[doc = " @retval #OS_ERRNO_HWI_NUM_INVALID              0x02000900: Invalid interrupt number."]
    #[doc = " @retval #LOS_OK                                0         : The interrupt is successfully delete."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_interrupt.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn ArchHwiDelete(hwiNum: HWI_HANDLE_T, irqParam: *mut HwiIrqParam) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_interrupt"]
    #[doc = " @brief Create a hardware interrupt."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to configure a hardware interrupt and register a hardware interrupt handling function."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The hardware interrupt module is usable only when the configuration item for hardware"]
    #[doc = " interrupt tailoring is enabled.</li>"]
    #[doc = " <li>Hardware interrupt number value range: [OS_USER_HWI_MIN,OS_USER_HWI_MAX]. The value range"]
    #[doc = " applicable for a Cortex-A7 platform is [32,95].</li>"]
    #[doc = " <li>OS_HWI_MAX_NUM specifies the maximum number of interrupts that can be created.</li>"]
    #[doc = " <li>Before executing an interrupt on a platform, refer to the chip manual of the platform.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  hwiNum   [IN] Type#HWI_HANDLE_T: hardware interrupt number. The value range applicable for a"]
    #[doc = "                       Cortex-A7 platform is [32,95]."]
    #[doc = " @param  hwiPrio  [IN] Type#HWI_PRIOR_T: hardware interrupt priority. Ignore this parameter temporarily."]
    #[doc = " @param  mode     [IN] Type#HWI_MODE_T: hardware interrupt mode. Ignore this parameter temporarily."]
    #[doc = " @param  handler  [IN] Type#HWI_PROC_FUNC: interrupt handler used when a hardware interrupt is triggered."]
    #[doc = " @param  irqParam [IN] Type#HwiIrqParam: input parameter of the interrupt"]
    #[doc = "                                         handler used when a hardware interrupt is triggered."]
    #[doc = ""]
    #[doc = " @retval #OS_ERRNO_HWI_PROC_FUNC_NULL               0x02000901: Null hardware interrupt handling function."]
    #[doc = " @retval #OS_ERRNO_HWI_NUM_INVALID                  0x02000900: Invalid interrupt number."]
    #[doc = " @retval #OS_ERRNO_HWI_NO_MEMORY                    0x02000903: Insufficient memory for hardware interrupt creation."]
    #[doc = " @retval #OS_ERRNO_HWI_ALREADY_CREATED              0x02000904: The interrupt handler being created has"]
    #[doc = "                                                                already been created."]
    #[doc = " @retval #LOS_OK                                    0         : The interrupt is successfully created."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_interrupt.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn ArchHwiCreate(
        hwiNum: HWI_HANDLE_T,
        hwiPrio: HWI_PRIOR_T,
        mode: HWI_MODE_T,
        handler: HWI_PROC_FUNC,
        irqParam: *mut HwiIrqParam,
    ) -> UINT32;
}
extern "C" {
    pub fn ArchIsIntActive() -> UINT32;
}
extern "C" {
    pub fn ArchIntLock() -> UINT32;
}
extern "C" {
    pub fn ArchIntUnLock() -> UINT32;
}
extern "C" {
    pub fn ArchIntRestore(intSave: UINT32);
}
extern "C" {
    pub fn ArchIntTrigger(hwiNum: HWI_HANDLE_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntEnable(hwiNum: HWI_HANDLE_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntDisable(hwiNum: HWI_HANDLE_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntClear(hwiNum: HWI_HANDLE_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntSetPriority(hwiNum: HWI_HANDLE_T, priority: HWI_PRIOR_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntCurIrqNum() -> UINT32;
}
extern "C" {
    pub fn ArchIntOpsGet() -> *mut HwiControllerOps;
}
extern "C" {
    #[doc = " @ingroup  los_context"]
    #[doc = " @brief: Task stack initialization."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to initialize the task stack."]
    #[doc = ""]
    #[doc = " @attention:"]
    #[doc = " <ul><li>None.</li></ul>"]
    #[doc = ""]
    #[doc = " @param  taskID     [IN] Type#UINT32: TaskID."]
    #[doc = " @param  stackSize  [IN] Type#UINT32: Total size of the stack."]
    #[doc = " @param  topStack   [IN] Type#VOID *: Top of task's stack."]
    #[doc = ""]
    #[doc = " @retval: context Type#TaskContext *."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_context.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn ArchTskStackInit(
        taskID: UINT32,
        stackSize: UINT32,
        topStack: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup  los_context"]
    #[doc = " @brief: Function to sys exit."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to sys exit."]
    #[doc = ""]
    #[doc = " @attention:"]
    #[doc = " <ul><li>None.</li></ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval: None."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_context.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn ArchSysExit();
}
extern "C" {
    #[doc = " @ingroup  los_context"]
    #[doc = " @brief: Task scheduling Function."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to scheduling task."]
    #[doc = ""]
    #[doc = " @attention:"]
    #[doc = " <ul><li>None.</li></ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval: None."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_context.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn ArchTaskSchedule();
}
extern "C" {
    pub fn ArchStartSchedule() -> UINT32;
}
extern "C" {
    pub fn ArchSignalContextInit(
        stackPointer: *mut ::std::os::raw::c_void,
        stackTop: *mut ::std::os::raw::c_void,
        sigHandler: UINTPTR,
        param: UINT32,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " @ingroup los_list"]
#[doc = " Structure of a node in a doubly linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOS_DL_LIST {
    #[doc = "< Current node's pointer to the previous node"]
    pub pstPrev: *mut LOS_DL_LIST,
    #[doc = "< Current node's pointer to the next node"]
    pub pstNext: *mut LOS_DL_LIST,
}
#[test]
fn bindgen_test_layout_LOS_DL_LIST() {
    assert_eq!(
        ::std::mem::size_of::<LOS_DL_LIST>(),
        16usize,
        concat!("Size of: ", stringify!(LOS_DL_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<LOS_DL_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(LOS_DL_LIST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_DL_LIST>())).pstPrev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_DL_LIST),
            "::",
            stringify!(pstPrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_DL_LIST>())).pstNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_DL_LIST),
            "::",
            stringify!(pstNext)
        )
    );
}
#[doc = " @ingroup los_event"]
#[doc = " Event control structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEvent {
    #[doc = "< Event mask in the event control block,"]
    #[doc = "indicating the event that has been logically processed."]
    pub uwEventID: UINT32,
    #[doc = "< Event control block linked list"]
    pub stEventList: LOS_DL_LIST,
}
#[test]
fn bindgen_test_layout_tagEvent() {
    assert_eq!(
        ::std::mem::size_of::<tagEvent>(),
        24usize,
        concat!("Size of: ", stringify!(tagEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<tagEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(tagEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagEvent>())).uwEventID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagEvent),
            "::",
            stringify!(uwEventID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagEvent>())).stEventList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagEvent),
            "::",
            stringify!(stEventList)
        )
    );
}
#[doc = " @ingroup los_event"]
#[doc = " Event control structure"]
pub type EVENT_CB_S = tagEvent;
#[doc = " @ingroup los_event"]
#[doc = " Event control structure"]
pub type PEVENT_CB_S = *mut tagEvent;
extern "C" {
    #[doc = " @ingroup los_event"]
    #[doc = " @brief Initialize an event control block."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to initialize the event control block pointed to by eventCB."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param eventCB [IN/OUT] Pointer to the event control block to be initialized."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_EVENT_PTR_NULL  Null pointer."]
    #[doc = " @retval #LOS_OK                    The event control block is successfully initialized."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_event.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_EventClear"]
    pub fn LOS_EventInit(eventCB: PEVENT_CB_S) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_event"]
    #[doc = " @brief Obtain an event specified by the event ID."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to check whether an event expected by the user occurs according to the event ID, event mask,"]
    #[doc = " and event reading mode, and process the event based on the event reading mode. The event ID must point to"]
    #[doc = " valid memory."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>When the mode is LOS_WAITMODE_CLR, the eventID is passed-out.</li>"]
    #[doc = " <li>Otherwise the eventID is passed-in.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param eventID      [IN/OUT] Pointer to the ID of the event to be checked."]
    #[doc = " @param eventMask    [IN] Mask of the event expected to occur by the user, indicating the event obtained after"]
    #[doc = " it is logically processed that matches the ID pointed to by mode."]
    #[doc = " @param mode         [IN] Event reading mode. The modes include LOS_WAITMODE_AND, LOS_WAITMODE_OR, LOS_WAITMODE_CLR."]
    #[doc = ""]
    #[doc = " @retval 0             The event expected by the user does not occur."]
    #[doc = " @retval #UINT32       The event expected by the user occurs."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_event.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_EventRead | LOS_EventWrite"]
    pub fn LOS_EventPoll(eventID: *mut UINT32, eventMask: UINT32, mode: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_event"]
    #[doc = " @brief Read an event."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to block or schedule a task that reads an event of which the event control block, event mask,"]
    #[doc = " reading mode,"]
    #[doc = " and timeout information are specified."]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>An error code and an event return value can be same. To differentiate the error code and return value, bit 25 of"]
    #[doc = " the event mask is forbidden to be used.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param eventCB      [IN/OUT] Pointer to the event control block to be checked. This parameter must point to"]
    #[doc = "                              valid memory."]
    #[doc = " @param eventMask    [IN]     Mask of the event expected to occur by the user, indicating the event obtained after"]
    #[doc = "                              it is logically processed that matches the ID pointed to by eventID."]
    #[doc = " @param mode         [IN]     Event reading mode."]
    #[doc = " @param timeOut      [IN]     Timeout interval of event reading (unit: Tick)."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_EVENT_SETBIT_INVALID     Bit 25 of the event mask cannot be set because"]
    #[doc = "                                             it is set to an error number."]
    #[doc = " @retval #LOS_ERRNO_EVENT_EVENTMASK_INVALID  The passed-in event reading mode is incorrect."]
    #[doc = " @retval #LOS_ERRNO_EVENT_READ_IN_INTERRUPT  The event is being read during an interrupt."]
    #[doc = " @retval #LOS_ERRNO_EVENT_FLAGS_INVALID      The event mode is invalid."]
    #[doc = " @retval #LOS_ERRNO_EVENT_READ_IN_LOCK       The event reading task is locked."]
    #[doc = " @retval #LOS_ERRNO_EVENT_PTR_NULL           The passed-in pointer is null."]
    #[doc = " @retval 0                                   The event expected by the user does not occur."]
    #[doc = " @retval #UINT32                             The event expected by the user occurs."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_event.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_EventPoll | LOS_EventWrite"]
    pub fn LOS_EventRead(
        eventCB: PEVENT_CB_S,
        eventMask: UINT32,
        mode: UINT32,
        timeOut: UINT32,
    ) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_event"]
    #[doc = " @brief Write an event."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to write an event specified by the passed-in event mask into an event control block"]
    #[doc = " pointed to by eventCB."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>To determine whether the LOS_EventRead API returns an event or an error code, bit 25 of the event mask"]
    #[doc = " is forbidden to be used.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param eventCB  [IN/OUT] Pointer to the event control block into which an event is to be written."]
    #[doc = " This parameter must point to valid memory."]
    #[doc = " @param events   [IN] Event mask to be written."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_EVENT_SETBIT_INVALID  Bit 25 of the event mask cannot be set to an event"]
    #[doc = " because it is set to an error code."]
    #[doc = " @retval #LOS_ERRNO_EVENT_PTR_NULL        Null pointer."]
    #[doc = " @retval #LOS_OK                          The event is successfully written."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_event.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_EventPoll | LOS_EventRead"]
    pub fn LOS_EventWrite(eventCB: PEVENT_CB_S, events: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_event"]
    #[doc = " @brief Clear the event of the eventCB by a specified eventMask."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to set the ID of an event that has a specified mask and of which the information is stored in"]
    #[doc = " an event control block pointed to by eventCB to 0. eventCB must point to valid memory.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The value of events needs to be reversed when it is passed-in.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param eventCB     [IN/OUT] Pointer to the event control block to be cleared."]
    #[doc = " @param eventMask   [IN]     Mask of the event to be cleared."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_EVENT_PTR_NULL  Null pointer."]
    #[doc = " @retval #LOS_OK                    The event is successfully cleared."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_event.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_EventPoll | LOS_EventRead | LOS_EventWrite"]
    pub fn LOS_EventClear(eventCB: PEVENT_CB_S, eventMask: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_event"]
    #[doc = " @brief Destroy an event."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to Destroy an event.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The specific event should be a valid one.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param eventCB     [IN/OUT] Pointer to the event control block to be Destroyed."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_EVENT_PTR_NULL Null pointer."]
    #[doc = " @retval #LOS_OK                   The event is successfully cleared."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_event.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_EventPoll | LOS_EventRead | LOS_EventWrite"]
    pub fn LOS_EventDestroy(eventCB: PEVENT_CB_S) -> UINT32;
}
extern "C" {
    pub fn OsEventReadOnce(
        eventCB: PEVENT_CB_S,
        eventMask: UINT32,
        mode: UINT32,
        timeOut: UINT32,
    ) -> UINT32;
}
extern "C" {
    pub fn OsEventWriteOnce(eventCB: PEVENT_CB_S, events: UINT32) -> UINT32;
}
#[doc = " @ingroup los_err"]
#[doc = " @brief Define the pointer to the error handling function."]
#[doc = ""]
#[doc = " @par Description:"]
#[doc = " This API is used to define the pointer to the error handling function."]
#[doc = " @attention"]
#[doc = " <ul>"]
#[doc = " <li>None.</li>"]
#[doc = " </ul>"]
#[doc = ""]
#[doc = " @param  fileName  [IN] Log file that stores error information."]
#[doc = " @param  lineNo    [IN] Line number of the erroneous line."]
#[doc = " @param  errorNo   [IN] Error code."]
#[doc = " @param  paraLen   [IN] Length of the input parameter pPara."]
#[doc = " @param  para      [IN] User label of the error."]
#[doc = ""]
#[doc = " @retval None."]
#[doc = " @par Dependency:"]
#[doc = " <ul><li>los_err.h: the header file that contains the API declaration.</li></ul>"]
#[doc = " @see None."]
pub type LOS_ERRORHANDLE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        fileName: *mut CHAR,
        lineNo: UINT32,
        errorNo: UINT32,
        paraLen: UINT32,
        para: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @ingroup los_err"]
    #[doc = " @brief Error handling function."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to perform different operations according to error types."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  fileName  [IN] Log file that stores error information."]
    #[doc = " @param  lineNo    [IN] Line number of the erroneous line which should not be OS_ERR_MAGIC_WORD."]
    #[doc = " @param  errorNo   [IN] Error code."]
    #[doc = " @param  paraLen   [IN] Length of the input parameter pPara."]
    #[doc = " @param  para      [IN] User label of the error."]
    #[doc = ""]
    #[doc = " @retval LOS_OK The error is successfully processed."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_err.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None"]
    pub fn LOS_ErrHandle(
        fileName: *mut CHAR,
        lineNo: UINT32,
        errorNo: UINT32,
        paraLen: UINT32,
        para: *mut ::std::os::raw::c_void,
    ) -> UINT32;
}
#[doc = " @ingroup los_err"]
#[doc = " Error handling function structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagUserErrFunc {
    #[doc = "< Hook function for error handling."]
    pub pfnHook: LOS_ERRORHANDLE_FUNC,
}
#[test]
fn bindgen_test_layout_tagUserErrFunc() {
    assert_eq!(
        ::std::mem::size_of::<tagUserErrFunc>(),
        8usize,
        concat!("Size of: ", stringify!(tagUserErrFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<tagUserErrFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(tagUserErrFunc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagUserErrFunc>())).pfnHook as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagUserErrFunc),
            "::",
            stringify!(pfnHook)
        )
    );
}
#[doc = " @ingroup los_err"]
#[doc = " Error handling function structure."]
pub type UserErrFunc = tagUserErrFunc;
pub const LOS_MODULE_ID_LOS_MOD_SYS: LOS_MODULE_ID = 0;
pub const LOS_MODULE_ID_LOS_MOD_MEM: LOS_MODULE_ID = 1;
pub const LOS_MODULE_ID_LOS_MOD_TSK: LOS_MODULE_ID = 2;
pub const LOS_MODULE_ID_LOS_MOD_SWTMR: LOS_MODULE_ID = 3;
pub const LOS_MODULE_ID_LOS_MOD_TICK: LOS_MODULE_ID = 4;
pub const LOS_MODULE_ID_LOS_MOD_MSG: LOS_MODULE_ID = 5;
pub const LOS_MODULE_ID_LOS_MOD_QUE: LOS_MODULE_ID = 6;
pub const LOS_MODULE_ID_LOS_MOD_SEM: LOS_MODULE_ID = 7;
pub const LOS_MODULE_ID_LOS_MOD_MBOX: LOS_MODULE_ID = 8;
pub const LOS_MODULE_ID_LOS_MOD_HWI: LOS_MODULE_ID = 9;
pub const LOS_MODULE_ID_LOS_MOD_HWWDG: LOS_MODULE_ID = 10;
pub const LOS_MODULE_ID_LOS_MOD_CACHE: LOS_MODULE_ID = 11;
pub const LOS_MODULE_ID_LOS_MOD_HWTMR: LOS_MODULE_ID = 12;
pub const LOS_MODULE_ID_LOS_MOD_MMU: LOS_MODULE_ID = 13;
pub const LOS_MODULE_ID_LOS_MOD_LOG: LOS_MODULE_ID = 14;
pub const LOS_MODULE_ID_LOS_MOD_ERR: LOS_MODULE_ID = 15;
pub const LOS_MODULE_ID_LOS_MOD_EXC: LOS_MODULE_ID = 16;
pub const LOS_MODULE_ID_LOS_MOD_CSTK: LOS_MODULE_ID = 17;
pub const LOS_MODULE_ID_LOS_MOD_MPU: LOS_MODULE_ID = 18;
pub const LOS_MODULE_ID_LOS_MOD_NMHWI: LOS_MODULE_ID = 19;
pub const LOS_MODULE_ID_LOS_MOD_TRACE: LOS_MODULE_ID = 20;
pub const LOS_MODULE_ID_LOS_MOD_IPC: LOS_MODULE_ID = 24;
pub const LOS_MODULE_ID_LOS_MOD_TIMER: LOS_MODULE_ID = 26;
pub const LOS_MODULE_ID_LOS_MOD_EVENT: LOS_MODULE_ID = 28;
pub const LOS_MODULE_ID_LOS_MOD_MUX: LOS_MODULE_ID = 29;
pub const LOS_MODULE_ID_LOS_MOD_CPUP: LOS_MODULE_ID = 30;
pub const LOS_MODULE_ID_LOS_MOD_HOOK: LOS_MODULE_ID = 31;
pub const LOS_MODULE_ID_LOS_MOD_PM: LOS_MODULE_ID = 32;
pub const LOS_MODULE_ID_LOS_MOD_LMK: LOS_MODULE_ID = 33;
pub const LOS_MODULE_ID_LOS_MOD_SHELL: LOS_MODULE_ID = 49;
pub const LOS_MODULE_ID_LOS_MOD_SIGNAL: LOS_MODULE_ID = 50;
pub const LOS_MODULE_ID_LOS_MOD_BUTT: LOS_MODULE_ID = 51;
pub type LOS_MODULE_ID = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArchTickTimer {
    pub freq: UINT32,
    pub irqNum: INT32,
    pub periodMax: UINT64,
    pub init: ::std::option::Option<unsafe extern "C" fn(tickHandler: HWI_PROC_FUNC) -> UINT32>,
    pub getCycle: ::std::option::Option<unsafe extern "C" fn(period: *mut UINT32) -> UINT64>,
    pub reload: ::std::option::Option<unsafe extern "C" fn(time: UINT64) -> UINT64>,
    pub lock: ::std::option::Option<unsafe extern "C" fn()>,
    pub unlock: ::std::option::Option<unsafe extern "C" fn()>,
    pub tickHandler: HWI_PROC_FUNC,
}
#[test]
fn bindgen_test_layout_ArchTickTimer() {
    assert_eq!(
        ::std::mem::size_of::<ArchTickTimer>(),
        64usize,
        concat!("Size of: ", stringify!(ArchTickTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<ArchTickTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(ArchTickTimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).freq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).irqNum as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(irqNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).periodMax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(periodMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).getCycle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(getCycle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).reload as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(reload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).lock as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).unlock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).tickHandler as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(tickHandler)
        )
    );
}
extern "C" {
    pub fn ArchEnterSleep() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_timer"]
    #[doc = " @brief Get tick timer control block."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to get tick timer control block."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @retval #tick timer control block"]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_timer.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn ArchSysTickTimerGet() -> *mut ArchTickTimer;
}
extern "C" {
    #[doc = "  @ingroup  los_tick"]
    #[doc = "  @brief: System timer cycles get function."]
    #[doc = ""]
    #[doc = "  @par Description:"]
    #[doc = "  This API is used to get system timer cycles."]
    #[doc = ""]
    #[doc = " @attention:"]
    #[doc = " <ul><li>None.</li></ul>"]
    #[doc = ""]
    #[doc = " @param: None."]
    #[doc = ""]
    #[doc = " @retval: current system cycles."]
    #[doc = ""]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    #[doc = ""]
    pub fn LOS_SysCycleGet() -> UINT64;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " Ticks per second"]
    pub static mut g_ticksPerSec: UINT32;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " Cycles per Second"]
    pub static mut g_uwCyclePerSec: UINT32;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " Cycles per Tick"]
    pub static mut g_cyclesPerTick: UINT32;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " System Clock"]
    pub static mut g_sysClock: UINT32;
}
#[doc = " @ingroup los_tick"]
#[doc = " system time structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TagSysTime {
    #[doc = "< value 1970 ~ 2038 or 1970 ~ 2100"]
    pub uwYear: UINT16,
    #[doc = "< value 1 - 12"]
    pub ucMonth: UINT8,
    #[doc = "< value 1 - 31"]
    pub ucDay: UINT8,
    #[doc = "< value 0 - 23"]
    pub ucHour: UINT8,
    #[doc = "< value 0 - 59"]
    pub ucMinute: UINT8,
    #[doc = "< value 0 - 59"]
    pub ucSecond: UINT8,
    #[doc = "< value 0 - 6"]
    pub ucWeek: UINT8,
}
#[test]
fn bindgen_test_layout_TagSysTime() {
    assert_eq!(
        ::std::mem::size_of::<TagSysTime>(),
        8usize,
        concat!("Size of: ", stringify!(TagSysTime))
    );
    assert_eq!(
        ::std::mem::align_of::<TagSysTime>(),
        2usize,
        concat!("Alignment of ", stringify!(TagSysTime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TagSysTime>())).uwYear as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TagSysTime),
            "::",
            stringify!(uwYear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TagSysTime>())).ucMonth as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TagSysTime),
            "::",
            stringify!(ucMonth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TagSysTime>())).ucDay as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(TagSysTime),
            "::",
            stringify!(ucDay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TagSysTime>())).ucHour as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TagSysTime),
            "::",
            stringify!(ucHour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TagSysTime>())).ucMinute as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TagSysTime),
            "::",
            stringify!(ucMinute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TagSysTime>())).ucSecond as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TagSysTime),
            "::",
            stringify!(ucSecond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TagSysTime>())).ucWeek as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(TagSysTime),
            "::",
            stringify!(ucWeek)
        )
    );
}
#[doc = " @ingroup los_tick"]
#[doc = " system time structure."]
pub type SYS_TIME_S = TagSysTime;
extern "C" {
    pub fn OsTickTimerReload(period: UINT64) -> UINT64;
}
extern "C" {
    pub fn OsTickTimerBaseReset(currTime: UINT64);
}
extern "C" {
    pub fn OsTickTimerInit() -> UINT32;
}
extern "C" {
    pub fn OsTickSysTimerStartTimeSet(currTime: UINT64);
}
#[doc = " @ingroup los_tick"]
#[doc = " @brief Adjust the system tick timer clock frequency function hooks."]
#[doc = ""]
#[doc = " @par Description:"]
#[doc = " This API is used to adjust the system tick timer clock frequency."]
#[doc = " @attention"]
#[doc = " <ul>"]
#[doc = " <li>None</li>"]
#[doc = " </ul>"]
#[doc = ""]
#[doc = " @param  param  [IN] Function parameters."]
#[doc = ""]
#[doc = " @retval              0: Adjust the system tick timer clock frequency failed."]
#[doc = " @retval more than zero: Adjust after the system tick timer clock frequency."]
#[doc = " @par Dependency:"]
#[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
#[doc = " @see None"]
pub type SYS_TICK_FREQ_ADJUST_FUNC =
    ::std::option::Option<unsafe extern "C" fn(param: UINTPTR) -> UINT32>;
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " @brief Adjust the system tick timer clock frequency."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to adjust the system tick timer clock frequency."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>This function needs to be invoked only when the clock frequency of the system tick timer adjust as a result of"]
    #[doc = " changing the CPU frequency.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  handler [IN] Adjust the system tick timer clock frequency function hooks."]
    #[doc = " @param param   [IN] Function parameters."]
    #[doc = ""]
    #[doc = " @retval LOS_OK or Error code."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None"]
    pub fn LOS_SysTickClockFreqAdjust(handler: SYS_TICK_FREQ_ADJUST_FUNC, param: UINTPTR)
        -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " @brief Obtain the number of Ticks."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain the number of Ticks."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @retval UINT64 The number of Ticks."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None"]
    pub fn LOS_TickCountGet() -> UINT64;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " @brief Obtain the number of cycles in one second."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain the number of cycles in one second."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @retval UINT32 Number of cycles obtained in one second."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None"]
    pub fn LOS_CyclePerTickGet() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " @brief Convert Ticks to milliseconds."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to convert Ticks to milliseconds."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The number of milliseconds obtained through the conversion is 32-bit.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  ticks  [IN] Number of Ticks. The value range is (0,OS_SYS_CLOCK)."]
    #[doc = ""]
    #[doc = " @retval UINT32 Number of milliseconds obtained through the conversion. Ticks are successfully converted to"]
    #[doc = " milliseconds."]
    #[doc = " @par  Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_MS2Tick"]
    pub fn LOS_Tick2MS(ticks: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " @brief Convert milliseconds to Ticks."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to convert milliseconds to Ticks."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>If the parameter passed in is equal to 0xFFFFFFFF, the retval is 0xFFFFFFFF. Pay attention to the value to be"]
    #[doc = " converted because data possibly overflows.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  millisec  [IN] Number of milliseconds."]
    #[doc = ""]
    #[doc = " @retval UINT32 Number of Ticks obtained through the conversion."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_Tick2MS"]
    pub fn LOS_MS2Tick(millisec: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " @brief Re-initializes the system tick timer."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to re-initialize the system Tick timer."]
    #[doc = " @attention"]
    #[doc = ""]
    #[doc = " @param timer        [IN] Specify the tick timer."]
    #[doc = " @param tickHandler  [IN] Tick Interrupts the execution of the hook function."]
    #[doc = ""]
    #[doc = " @retval LOS_OK or Error code."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_TickTimerRegister(timer: *const ArchTickTimer, tickHandler: HWI_PROC_FUNC)
        -> UINT32;
}
extern "C" {
    pub fn LOS_UDelay(microseconds: UINT64);
}
extern "C" {
    pub fn LOS_MDelay(millisec: UINT32);
}
extern "C" {
    pub fn LOS_CurrNanosec() -> UINT64;
}
extern "C" {
    #[doc = " @ingroup  los_tick"]
    #[doc = " @brief Handle the system tick timeout."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is called when the system tick timeout and triggers the interrupt."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param none."]
    #[doc = ""]
    #[doc = " @retval None."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn OsTickHandler();
}
#[doc = " @ingroup los_tick"]
#[doc = " Define the CPU Tick structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TagCpuTick {
    pub cntHi: UINT32,
    pub cntLo: UINT32,
}
#[test]
fn bindgen_test_layout_TagCpuTick() {
    assert_eq!(
        ::std::mem::size_of::<TagCpuTick>(),
        8usize,
        concat!("Size of: ", stringify!(TagCpuTick))
    );
    assert_eq!(
        ::std::mem::align_of::<TagCpuTick>(),
        4usize,
        concat!("Alignment of ", stringify!(TagCpuTick))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TagCpuTick>())).cntHi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TagCpuTick),
            "::",
            stringify!(cntHi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TagCpuTick>())).cntLo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TagCpuTick),
            "::",
            stringify!(cntLo)
        )
    );
}
#[doc = " @ingroup los_tick"]
#[doc = " Define the CPU Tick structure."]
pub type CpuTick = TagCpuTick;
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " @brief Convert cycles to milliseconds."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to convert cycles to milliseconds."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  cpuTick  [IN]  Number of CPU cycles."]
    #[doc = " @param  msHi     [OUT] Upper 32 bits of the number of milliseconds."]
    #[doc = " @param  msLo     [OUT] Lower 32 bits of the number of milliseconds."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_SYS_PTR_NULL    0x02000011: Invalid parameter."]
    #[doc = " @retval #LOS_OK                   0:  Cycles are successfully converted to microseconds."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn OsCpuTick2MS(cpuTick: *mut CpuTick, msHi: *mut UINT32, msLo: *mut UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_tick"]
    #[doc = " @brief Convert cycles to microseconds."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to convert cycles to microseconds."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  cpuTick  [IN]  Number of CPU cycles."]
    #[doc = " @param  usHi     [OUT] Upper 32 bits of the number of microseconds."]
    #[doc = " @param  usLo     [OUT] Lower 32 bits of the number of microseconds."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_SYS_PTR_NULL    0x02000011: Invalid parameter."]
    #[doc = " @retval #LOS_OK                   0: Cycles are successfully converted to microseconds."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_tick.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn OsCpuTick2US(cpuTick: *mut CpuTick, usHi: *mut UINT32, usLo: *mut UINT32) -> UINT32;
}
pub const SortLinkType_OS_SORT_LINK_TASK: SortLinkType = 1;
pub const SortLinkType_OS_SORT_LINK_SWTMR: SortLinkType = 2;
pub type SortLinkType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortLinkList {
    pub sortLinkNode: LOS_DL_LIST,
    pub responseTime: UINT64,
}
#[test]
fn bindgen_test_layout_SortLinkList() {
    assert_eq!(
        ::std::mem::size_of::<SortLinkList>(),
        24usize,
        concat!("Size of: ", stringify!(SortLinkList))
    );
    assert_eq!(
        ::std::mem::align_of::<SortLinkList>(),
        8usize,
        concat!("Alignment of ", stringify!(SortLinkList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortLinkList>())).sortLinkNode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SortLinkList),
            "::",
            stringify!(sortLinkNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortLinkList>())).responseTime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SortLinkList),
            "::",
            stringify!(responseTime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortLinkAttribute {
    pub sortLink: LOS_DL_LIST,
}
#[test]
fn bindgen_test_layout_SortLinkAttribute() {
    assert_eq!(
        ::std::mem::size_of::<SortLinkAttribute>(),
        16usize,
        concat!("Size of: ", stringify!(SortLinkAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<SortLinkAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(SortLinkAttribute))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortLinkAttribute>())).sortLink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SortLinkAttribute),
            "::",
            stringify!(sortLink)
        )
    );
}
extern "C" {
    pub static mut g_taskSortLink: SortLinkAttribute;
}
extern "C" {
    pub static mut g_swtmrSortLink: SortLinkAttribute;
}
extern "C" {
    pub fn OsGetSortLinkAttribute(type_: SortLinkType) -> *mut SortLinkAttribute;
}
extern "C" {
    pub fn OsSortLinkInit(sortLinkHead: *mut SortLinkAttribute) -> UINT32;
}
extern "C" {
    pub fn OsAdd2SortLink(
        node: *mut SortLinkList,
        startTime: UINT64,
        waitTicks: UINT32,
        type_: SortLinkType,
    );
}
extern "C" {
    pub fn OsDeleteSortLink(node: *mut SortLinkList);
}
extern "C" {
    pub fn OsSortLinkGetTargetExpireTime(
        currTime: UINT64,
        targetSortList: *const SortLinkList,
    ) -> UINT64;
}
extern "C" {
    pub fn OsSortLinkGetNextExpireTime(sortLinkHead: *const SortLinkAttribute) -> UINT64;
}
extern "C" {
    pub fn OsSortLinkResponseTimeConvertFreq(oldFreq: UINT32);
}
#[doc = " @ingroup los_task"]
#[doc = " Define the type of the task entry function."]
#[doc = ""]
pub type TSK_ENTRY_FUNC =
    ::std::option::Option<unsafe extern "C" fn(arg: UINT32) -> *mut ::std::os::raw::c_void>;
#[doc = " @ingroup los_task"]
#[doc = " Define the structure of the parameters used for task creation."]
#[doc = ""]
#[doc = " Information of specified parameters passed in during task creation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTskInitParam {
    #[doc = "< Task entrance function"]
    pub pfnTaskEntry: TSK_ENTRY_FUNC,
    #[doc = "< Task priority"]
    pub usTaskPrio: UINT16,
    #[doc = "< Task parameters"]
    pub uwArg: UINT32,
    #[doc = "< Task stack memory"]
    pub stackAddr: UINTPTR,
    #[doc = "< Task stack size"]
    pub uwStackSize: UINT32,
    #[doc = "< Task name"]
    pub pcName: *mut CHAR,
    #[doc = "< Reserved"]
    pub uwResved: UINT32,
}
#[test]
fn bindgen_test_layout_tagTskInitParam() {
    assert_eq!(
        ::std::mem::size_of::<tagTskInitParam>(),
        40usize,
        concat!("Size of: ", stringify!(tagTskInitParam))
    );
    assert_eq!(
        ::std::mem::align_of::<tagTskInitParam>(),
        8usize,
        concat!("Alignment of ", stringify!(tagTskInitParam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInitParam>())).pfnTaskEntry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInitParam),
            "::",
            stringify!(pfnTaskEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInitParam>())).usTaskPrio as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInitParam),
            "::",
            stringify!(usTaskPrio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInitParam>())).uwArg as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInitParam),
            "::",
            stringify!(uwArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInitParam>())).stackAddr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInitParam),
            "::",
            stringify!(stackAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInitParam>())).uwStackSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInitParam),
            "::",
            stringify!(uwStackSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInitParam>())).pcName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInitParam),
            "::",
            stringify!(pcName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInitParam>())).uwResved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInitParam),
            "::",
            stringify!(uwResved)
        )
    );
}
#[doc = " @ingroup los_task"]
#[doc = " Define the structure of the parameters used for task creation."]
#[doc = ""]
#[doc = " Information of specified parameters passed in during task creation."]
pub type TSK_INIT_PARAM_S = tagTskInitParam;
#[doc = " @ingroup los_task"]
#[doc = " Task information structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTskInfo {
    #[doc = "< Task entrance function"]
    pub acName: [CHAR; 32usize],
    #[doc = "< Task ID"]
    pub uwTaskID: UINT32,
    #[doc = "< Task status"]
    pub usTaskStatus: UINT16,
    #[doc = "< Task priority"]
    pub usTaskPrio: UINT16,
    #[doc = "< Semaphore pointer"]
    pub pTaskSem: *mut ::std::os::raw::c_void,
    #[doc = "< Mutex pointer"]
    pub pTaskMux: *mut ::std::os::raw::c_void,
    #[doc = "< Sem ID"]
    pub uwSemID: UINT32,
    #[doc = "< Mux ID"]
    pub uwMuxID: UINT32,
    #[doc = "< Event"]
    pub uwEvent: EVENT_CB_S,
    #[doc = "< Event mask"]
    pub uwEventMask: UINT32,
    #[doc = "< Task stack size"]
    pub uwStackSize: UINT32,
    #[doc = "< Task stack top"]
    pub uwTopOfStack: UINT32,
    #[doc = "< Task stack bottom"]
    pub uwBottomOfStack: UINT32,
    #[doc = "< Task SP pointer"]
    pub uwSP: UINT32,
    #[doc = "< Current task stack usage"]
    pub uwCurrUsed: UINT32,
    #[doc = "< Task stack usage peak"]
    pub uwPeakUsed: UINT32,
    #[doc = "< Flag that indicates whether a task stack overflow occurs"]
    pub bOvf: BOOL,
}
#[test]
fn bindgen_test_layout_tagTskInfo() {
    assert_eq!(
        ::std::mem::size_of::<tagTskInfo>(),
        120usize,
        concat!("Size of: ", stringify!(tagTskInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<tagTskInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(tagTskInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).acName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(acName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwTaskID as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwTaskID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).usTaskStatus as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(usTaskStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).usTaskPrio as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(usTaskPrio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).pTaskSem as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(pTaskSem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).pTaskMux as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(pTaskMux)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwSemID as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwSemID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwMuxID as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwMuxID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwEvent as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwEventMask as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwEventMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwStackSize as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwStackSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwTopOfStack as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwTopOfStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwBottomOfStack as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwBottomOfStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwSP as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwSP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwCurrUsed as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwCurrUsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).uwPeakUsed as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(uwPeakUsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTskInfo>())).bOvf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTskInfo),
            "::",
            stringify!(bOvf)
        )
    );
}
#[doc = " @ingroup los_task"]
#[doc = " Task information structure."]
pub type TSK_INFO_S = tagTskInfo;
extern "C" {
    #[doc = " @ingroup los_task"]
    #[doc = " @brief Sleep the current task."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to delay the execution of the current task. The task is able to be scheduled"]
    #[doc = " after it is delayed for a specified number of Ticks."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The task fails to be delayed if it is being delayed during interrupt processing or it is locked.</li>"]
    #[doc = " <li>If 0 is passed in and the task scheduling is not locked,"]
    #[doc = " execute the next task in the queue of tasks with the priority of the current task."]
    #[doc = " If no ready task with the priority of the current task is available,"]
    #[doc = " the task scheduling will not occur, and the current task continues to be executed.</li>"]
    #[doc = " <li>The parameter passed in can not be equal to LOS_WAIT_FOREVER(0xFFFFFFFF)."]
    #[doc = " If that happens, the task will not sleep 0xFFFFFFFF milliseconds or sleep forever but sleep 0xFFFFFFFF Ticks.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param mSecs [IN] Type #UINT32 Number of MS for which the task is delayed."]
    #[doc = ""]
    #[doc = " @retval None"]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None"]
    pub fn LOS_Msleep(mSecs: UINT32);
}
extern "C" {
    #[doc = " @ingroup los_task"]
    #[doc = " @brief System kernel initialization function."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to start liteOS ."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param: None."]
    #[doc = ""]
    #[doc = " @retval #LOS_OK                                  0:LiteOS start success."]
    #[doc = ""]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_config.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_Start() -> UINT32;
}
extern "C" {
    pub fn LOS_Reboot();
}
extern "C" {
    pub fn LOS_Panic(fmt: *const CHAR, ...);
}
extern "C" {
    #[doc = " @ingroup los_task"]
    #[doc = " @brief System kernel initialization function."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to Initialize kernel ,configure all system modules."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param: None."]
    #[doc = ""]
    #[doc = " @retval #LOS_OK                                  0:System kernel initialization success."]
    #[doc = ""]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_config.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_KernelInit() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Create a task and suspend."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to create a task and suspend it. This task will not be added to the queue of ready tasks before"]
    #[doc = " resume it."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>During task creation, the task control block and task stack of the task that is previously automatically deleted"]
    #[doc = " are deallocated.</li>"]
    #[doc = " <li>The task name is a pointer and is not allocated memory.</li>"]
    #[doc = " <li>If the size of the task stack of the task to be created is 0, configure #LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE"]
    #[doc = " to specify the default task stack size. The stack size should be a reasonable value, if the size is too large, may"]
    #[doc = " cause memory exhaustion.</li>"]
    #[doc = " <li>The task stack size must be aligned on the boundary of 8 bytes. The size is determined by whether it is big"]
    #[doc = " enough to avoid task stack overflow.</li>"]
    #[doc = " <li>Less parameter value indicates higher task priority.</li>"]
    #[doc = " <li>The task name cannot be null.</li>"]
    #[doc = " <li>The pointer to the task executing function cannot be null.</li>"]
    #[doc = " <li>The two parameters of this interface is pointer, it should be a correct value, otherwise, the system may be"]
    #[doc = " abnormal.</li>"]
    #[doc = " <li>If user mode is enabled, user should input user stack pointer and size, the size must fit the stack pointer,"]
    #[doc = " uwStackSize remain as the kernel stack size.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskID        [OUT] Type  #UINT32 * Task ID."]
    #[doc = " @param  taskInitParam [IN]  Type  #TSK_INIT_PARAM_S * Parameter for task creation."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID        Invalid Task ID, param puwTaskID is NULL."]
    #[doc = " @retval #LOS_ERRNO_TSK_PTR_NULL          Param pstInitParam is NULL."]
    #[doc = " @retval #LOS_ERRNO_TSK_NAME_EMPTY        The task name is NULL."]
    #[doc = " @retval #LOS_ERRNO_TSK_ENTRY_NULL        The task entrance is NULL."]
    #[doc = " @retval #LOS_ERRNO_TSK_PRIOR_ERROR       Incorrect task priority."]
    #[doc = " @retval #LOS_ERRNO_TSK_STKSZ_TOO_LARGE   The task stack size is too large."]
    #[doc = " @retval #LOS_ERRNO_TSK_STKSZ_TOO_SMALL   The task stack size is too small."]
    #[doc = " @retval #LOS_ERRNO_TSK_TCB_UNAVAILABLE   No free task control block is available."]
    #[doc = " @retval #LOS_ERRNO_TSK_NO_MEMORY         Insufficient memory for task creation."]
    #[doc = " @retval #LOS_OK                          The task is successfully created."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " <ul><li>los_config.h: the header file that contains system configuration items.</li></ul>"]
    #[doc = " @see LOS_TaskDelete"]
    pub fn LOS_TaskCreateOnly(taskID: *mut UINT32, taskInitParam: *mut TSK_INIT_PARAM_S) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Create a task."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to create a task. If the priority of the task created after system initialized is higher than"]
    #[doc = " the current task and task scheduling is not locked, it is scheduled for running."]
    #[doc = " If not, the created task is added to the queue of ready tasks."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>During task creation, the task control block and task stack of the task that is previously automatically"]
    #[doc = " deleted are deallocated.</li>"]
    #[doc = " <li>The task name is a pointer and is not allocated memory.</li>"]
    #[doc = " <li>If the size of the task stack of the task to be created is 0, configure #LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE"]
    #[doc = " to specify the default task stack size.</li>"]
    #[doc = " <li>The task stack size must be aligned on the boundary of 8 bytes. The size is determined by whether it is big"]
    #[doc = " enough to avoid task stack overflow.</li>"]
    #[doc = " <li>Less parameter value indicates higher task priority.</li>"]
    #[doc = " <li>The task name cannot be null.</li>"]
    #[doc = " <li>The pointer to the task executing function cannot be null.</li>"]
    #[doc = " <li>The two parameters of this interface is pointer, it should be a correct value, otherwise, the system may be"]
    #[doc = " abnormal.</li>"]
    #[doc = " <li>If user mode is enabled, user should input user stack pointer and size, the size must fit the stack pointer,"]
    #[doc = " uwStackSize remain as the kernel stack size.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskID        [OUT] Type  #UINT32 * Task ID."]
    #[doc = " @param  taskInitParam [IN]  Type  #TSK_INIT_PARAM_S * Parameter for task creation."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID        Invalid Task ID, param puwTaskID is NULL."]
    #[doc = " @retval #LOS_ERRNO_TSK_PTR_NULL          Param pstInitParam is NULL."]
    #[doc = " @retval #LOS_ERRNO_TSK_NAME_EMPTY        The task name is NULL."]
    #[doc = " @retval #LOS_ERRNO_TSK_ENTRY_NULL        The task entrance is NULL."]
    #[doc = " @retval #LOS_ERRNO_TSK_PRIOR_ERROR       Incorrect task priority."]
    #[doc = " @retval #LOS_ERRNO_TSK_STKSZ_TOO_LARGE   The task stack size is too large."]
    #[doc = " @retval #LOS_ERRNO_TSK_STKSZ_TOO_SMALL   The task stack size is too small."]
    #[doc = " @retval #LOS_ERRNO_TSK_TCB_UNAVAILABLE   No free task control block is available."]
    #[doc = " @retval #LOS_ERRNO_TSK_NO_MEMORY         Insufficient memory for task creation."]
    #[doc = " @retval #LOS_OK                          The task is successfully created."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " <ul><li>los_config.h: the header file that contains system configuration items.</li></ul>"]
    #[doc = " @see LOS_TaskDelete"]
    pub fn LOS_TaskCreate(taskID: *mut UINT32, taskInitParam: *mut TSK_INIT_PARAM_S) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Resume a task."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to resume a suspended task."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>If the task is delayed or blocked, resume the task without adding it to the queue of ready tasks.</li>"]
    #[doc = " <li>If the priority of the task resumed after system initialized is higher than the current task and task scheduling"]
    #[doc = " is not locked, it is scheduled for running.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskID [IN] Type #UINT32 Task ID. The task id value is obtained from task creation."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID        Invalid Task ID"]
    #[doc = " @retval #LOS_ERRNO_TSK_NOT_CREATED       The task is not created."]
    #[doc = " @retval #LOS_ERRNO_TSK_NOT_SUSPENDED     The task is not suspended."]
    #[doc = " @retval #LOS_OK                          The task is successfully resumed."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_TaskSuspend"]
    pub fn LOS_TaskResume(taskID: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Suspend a task."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to suspend a specified task, and the task will be removed from the queue of ready tasks."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The task that is running and locked cannot be suspended.</li>"]
    #[doc = " <li>The idle task and swtmr task cannot be suspended.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskID [IN] Type #UINT32 Task ID. The task id value is obtained from task creation."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_OPERATE_IDLE                  Check the task ID and do not operate on the idle task."]
    #[doc = " @retval #LOS_ERRNO_TSK_SUSPEND_SWTMR_NOT_ALLOWED     Check the task ID and do not operate on the swtmr task."]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID                    Invalid Task ID"]
    #[doc = " @retval #LOS_ERRNO_TSK_NOT_CREATED                   The task is not created."]
    #[doc = " @retval #LOS_ERRNO_TSK_ALREADY_SUSPENDED             The task is already suspended."]
    #[doc = " @retval #LOS_ERRNO_TSK_SUSPEND_LOCKED                The task being suspended is current task and task scheduling"]
    #[doc = "                                                      is locked."]
    #[doc = " @retval #LOS_OK                                      The task is successfully suspended."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_TaskResume"]
    pub fn LOS_TaskSuspend(taskID: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Delete a task."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to delete a specified task and release the resources for its task stack and task control block."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The idle task and swtmr task cannot be deleted.</li>"]
    #[doc = " <li>If delete current task maybe cause unexpected error.</li>"]
    #[doc = " <li>If a task get a mutex is deleted or automatically deleted before release this mutex, other tasks pended"]
    #[doc = " this mutex maybe never be scheduled.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskID [IN] Type #UINT32 Task ID. The task id value is obtained from task creation."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_OPERATE_IDLE                  Check the task ID and do not operate on the idle task."]
    #[doc = " @retval #LOS_ERRNO_TSK_SUSPEND_SWTMR_NOT_ALLOWED     Check the task ID and do not operate on the swtmr task."]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID                    Invalid Task ID"]
    #[doc = " @retval #LOS_ERRNO_TSK_NOT_CREATED                   The task is not created."]
    #[doc = " @retval #LOS_OK                                      The task is successfully deleted."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_TaskCreate | LOS_TaskCreateOnly"]
    pub fn LOS_TaskDelete(taskID: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Delay a task."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to delay the execution of the current task. The task is able to be scheduled after it is delayed"]
    #[doc = " for a specified number of Ticks."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The task fails to be delayed if it is being delayed during interrupt processing or it is locked.</li>"]
    #[doc = " <li>If 0 is passed in and the task scheduling is not locked, execute the next task in the queue of tasks with"]
    #[doc = " the same priority of the current task."]
    #[doc = " If no ready task with the priority of the current task is available, the task scheduling will not occur, and the"]
    #[doc = " current task continues to be executed.</li>"]
    #[doc = " <li>Using the interface before system initialized is not allowed.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  tick [IN] Type #UINT32 Number of Ticks for which the task is delayed."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_DELAY_IN_INT              The task delay occurs during an interrupt."]
    #[doc = " @retval #LOS_ERRNO_TSK_DELAY_IN_LOCK             The task delay occurs when the task scheduling is locked."]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID                Invalid Task ID"]
    #[doc = " @retval #LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK     No tasks with the same priority is available for scheduling."]
    #[doc = " @retval #LOS_OK                                  The task is successfully delayed."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_TaskDelay(tick: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Lock the task scheduling."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to lock the task scheduling. Task switching will not occur if the task scheduling is locked."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>If the task scheduling is locked, but interrupts are not disabled, tasks are still able to be interrupted.</li>"]
    #[doc = " <li>One is added to the number of task scheduling locks if this API is called. The number of locks is decreased by"]
    #[doc = " one if the task scheduling is unlocked. Therefore, this API should be used together with LOS_TaskUnlock.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval None."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_TaskUnlock"]
    pub fn LOS_TaskLock();
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Unlock the task scheduling."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to unlock the task scheduling. Calling this API will decrease the number of task locks by one."]
    #[doc = " If a task is locked more than once, the task scheduling will be unlocked only when the number of locks becomes zero."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The number of locks is decreased by one if this API is called. One is added to the number of task scheduling"]
    #[doc = " locks if the task scheduling is locked. Therefore, this API should be used together with LOS_TaskLock.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval None."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_TaskLock"]
    pub fn LOS_TaskUnlock();
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Set a task priority."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to set the priority of a specified task."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>If the set priority is higher than the priority of the current running task, task scheduling probably occurs."]
    #[doc = " </li>"]
    #[doc = " <li>Changing the priority of the current running task also probably causes task scheduling.</li>"]
    #[doc = " <li>Using the interface to change the priority of software timer task and idle task is not allowed.</li>"]
    #[doc = " <li>Using the interface in the interrupt is not allowed.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskID   [IN] Type #UINT32 Task ID. The task id value is obtained from task creation."]
    #[doc = " @param  taskPrio [IN] Type #UINT16 Task priority."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_PRIOR_ERROR    Incorrect task priority.Re-configure the task priority"]
    #[doc = " @retval #LOS_ERRNO_TSK_OPERATE_IDLE   Check the task ID and do not operate on the idle task."]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID     Invalid Task ID"]
    #[doc = " @retval #LOS_ERRNO_TSK_NOT_CREATED    The task is not created."]
    #[doc = " @retval #LOS_OK                       The task priority is successfully set to a specified priority."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_TaskPriSet"]
    pub fn LOS_TaskPriSet(taskID: UINT32, taskPrio: UINT16) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Set the priority of the current running task to a specified priority."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to set the priority of the current running task to a specified priority."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>Changing the priority of the current running task probably causes task scheduling.</li>"]
    #[doc = " <li>Using the interface to change the priority of software timer task and idle task is not allowed.</li>"]
    #[doc = " <li>Using the interface in the interrupt is not allowed.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskPrio [IN] Type #UINT16 Task priority."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_PRIOR_ERROR     Incorrect task priority.Re-configure the task priority"]
    #[doc = " @retval #LOS_ERRNO_TSK_OPERATE_IDLE    Check the task ID and do not operate on the idle task."]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID      Invalid Task ID"]
    #[doc = " @retval #LOS_ERRNO_TSK_NOT_CREATED     The task is not created."]
    #[doc = " @retval #LOS_OK                        The priority of the current running task is successfully set to a specified"]
    #[doc = "                                        priority."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_TaskPriGet"]
    pub fn LOS_CurTaskPriSet(taskPrio: UINT16) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Change the scheduling sequence of tasks with the same priority."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to move current task in a queue of tasks with the same priority to the tail of the queue of ready"]
    #[doc = " tasks."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>At least two ready tasks need to be included in the queue of ready tasks with the same priority. If the"]
    #[doc = " less than two ready tasks are included in the queue, an error is reported.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID                    Invalid Task ID"]
    #[doc = " @retval #LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK         No tasks with the same priority is available for scheduling."]
    #[doc = " @retval #LOS_OK                                      The scheduling sequence of tasks with same priority is"]
    #[doc = "                                                      successfully changed."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_TaskYield() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain a task priority."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain the priority of a specified task."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param  taskID [IN] Type #UINT32 Task ID. The task id value is obtained from task creation."]
    #[doc = ""]
    #[doc = " @retval #OS_INVALID      The task priority fails to be obtained."]
    #[doc = " @retval #UINT16          The task priority."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_TaskPriSet"]
    pub fn LOS_TaskPriGet(taskID: UINT32) -> UINT16;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain current running task ID."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain the ID of current running task."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li> This interface should not be called before system initialized.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID    Invalid Task ID."]
    #[doc = " @retval #UINT32                      Task ID."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_CurTaskIDGet() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain next running task ID."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain the ID of next running task."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID    invalid Task ID."]
    #[doc = " @retval #UINT32                      task id."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_NextTaskIDGet() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain next running task ID."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain the ID of next running task."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @retval #NULL            invalid Task name."]
    #[doc = " @retval #CHAR*           task name."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_CurTaskNameGet() -> *mut CHAR;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain a task information structure."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain a task information structure."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>One parameter of this interface is a pointer, it should be a correct value, otherwise, the system may be"]
    #[doc = " abnormal.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskID    [IN]  Type  #UINT32 Task ID. The task id value is obtained from task creation."]
    #[doc = " @param  taskInfo  [OUT] Type  #TSK_INFO_S* Pointer to the task information structure to be obtained."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_PTR_NULL        Null parameter."]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID      Invalid task ID."]
    #[doc = " @retval #LOS_ERRNO_TSK_NOT_CREATED     The task is not created."]
    #[doc = " @retval #LOS_OK                        The task information structure is successfully obtained."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_TaskInfoGet(taskID: UINT32, taskInfo: *mut TSK_INFO_S) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain the task status."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain the task status."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param  taskID     [IN] Type  #TSK_HANDLE_T Task ID."]
    #[doc = " @param  taskStatus [OUT] Type  #UINT32 Pointer to the task status to be obtained."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_PTR_NULL                    0x02000201: Null parameter."]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID                  0x02000207: Invalid task ID."]
    #[doc = " @retval #LOS_ERRNO_TSK_NOT_CREATED                 0x0200020a: The task is not created."]
    #[doc = " @retval #LOS_OK                                   0: The task information structure is successfully obtained."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_TaskStatusGet(taskID: UINT32, taskStatus: *mut UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_monitor"]
    #[doc = " @brief Obtain all tasks info."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain all tasks info."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>This API can be called only after the CPU usage is initialized. Otherwise, -1 will be returned.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param None."]
    #[doc = ""]
    #[doc = " @retval #OS_ERROR           -1:all tasks info obtain failed."]
    #[doc = " @retval #LOS_OK              0:all tasks info is successfully obtained."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_monitor.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_TaskInfoMonitor"]
    pub fn LOS_TaskInfoMonitor() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain tasks switch info."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain tasks switch info."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param  index            [IN]  Type  #UINT32  Switch info array index."]
    #[doc = " @param  taskSwitchInfo   [OUT] Type  #UINT32* First 4 bytes is task id, and then is task name, name len is"]
    #[doc = "                                OS_TSK_NAME_LEN."]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_PTR_NULL           0x02000201: Null parameter."]
    #[doc = " @retval #LOS_OK                           0: The task switch information is successfully obtained."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_TaskSwitchInfoGet(index: UINT32, taskSwitchInfo: *mut UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain tasks schduling info."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain task is scheduled."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param None."]
    #[doc = ""]
    #[doc = " @retval #TRUE         Tasks is scheduled."]
    #[doc = " @retval #FALSE        Tasks not scheduling yet."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_TaskIsRunning() -> BOOL;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain current new task ID."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain the ID of new task."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @retval #LOS_ERRNO_TSK_ID_INVALID    0x02000207: invalid Task ID."]
    #[doc = " @retval # Task ID."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_NewTaskIDGet() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Obtain the task name."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to obtain the task name."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param  taskID            [IN]  Task ID."]
    #[doc = ""]
    #[doc = " @retval #NULL: invalid Task name."]
    #[doc = " @retval # Task name."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_TaskNameGet(taskID: UINT32) -> *mut CHAR;
}
extern "C" {
    pub fn LOS_TaskJoin(taskID: UINT32, retval: *mut UINTPTR) -> UINT32;
}
extern "C" {
    pub fn LOS_TaskDetach(taskID: UINT32) -> UINT32;
}
#[doc = " @ingroup los_task"]
#[doc = " Define the task control block structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LosTaskCB {
    #[doc = "< Task stack pointer"]
    pub stackPointer: *mut ::std::os::raw::c_void,
    pub taskStatus: UINT16,
    pub priority: UINT16,
    pub timeSlice: INT32,
    pub waitTimes: UINT32,
    pub sortList: SortLinkList,
    pub startTime: UINT64,
    #[doc = "< Task stack size"]
    pub stackSize: UINT32,
    #[doc = "< Task stack top"]
    pub topOfStack: UINT32,
    #[doc = "< Task ID"]
    pub taskID: UINT32,
    #[doc = "< Task entrance function"]
    pub taskEntry: TSK_ENTRY_FUNC,
    #[doc = "< Task-held semaphore"]
    pub taskSem: *mut ::std::os::raw::c_void,
    #[doc = "< Task-held mutex"]
    pub taskMux: *mut ::std::os::raw::c_void,
    #[doc = "< Parameter"]
    pub arg: UINT32,
    #[doc = "< Task name"]
    pub taskName: *mut CHAR,
    pub pendList: LOS_DL_LIST,
    pub timerList: LOS_DL_LIST,
    pub joinList: LOS_DL_LIST,
    #[doc = "< Return value of the end of the task, If the task does not exit by itself, the ID of the task that killed the task is recorded."]
    pub joinRetval: UINTPTR,
    pub event: EVENT_CB_S,
    #[doc = "< Event mask"]
    pub eventMask: UINT32,
    #[doc = "< Event mode"]
    pub eventMode: UINT32,
    #[doc = "< Memory allocated to queues"]
    pub msg: *mut ::std::os::raw::c_void,
    pub errorNo: INT32,
}
#[test]
fn bindgen_test_layout_LosTaskCB() {
    assert_eq!(
        ::std::mem::size_of::<LosTaskCB>(),
        216usize,
        concat!("Size of: ", stringify!(LosTaskCB))
    );
    assert_eq!(
        ::std::mem::align_of::<LosTaskCB>(),
        8usize,
        concat!("Alignment of ", stringify!(LosTaskCB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).stackPointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(stackPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).taskStatus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(taskStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).priority as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).timeSlice as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(timeSlice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).waitTimes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(waitTimes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).sortList as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(sortList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).startTime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(startTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).stackSize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(stackSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).topOfStack as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(topOfStack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).taskID as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(taskID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).taskEntry as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(taskEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).taskSem as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(taskSem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).taskMux as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(taskMux)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).arg as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).taskName as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(taskName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).pendList as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(pendList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).timerList as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(timerList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).joinList as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(joinList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).joinRetval as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(joinRetval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).event as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).eventMask as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(eventMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).eventMode as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(eventMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).msg as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTaskCB>())).errorNo as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTaskCB),
            "::",
            stringify!(errorNo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LosTask {
    pub runTask: *mut LosTaskCB,
    pub newTask: *mut LosTaskCB,
}
#[test]
fn bindgen_test_layout_LosTask() {
    assert_eq!(
        ::std::mem::size_of::<LosTask>(),
        16usize,
        concat!("Size of: ", stringify!(LosTask))
    );
    assert_eq!(
        ::std::mem::align_of::<LosTask>(),
        8usize,
        concat!("Alignment of ", stringify!(LosTask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTask>())).runTask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTask),
            "::",
            stringify!(runTask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosTask>())).newTask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LosTask),
            "::",
            stringify!(newTask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TaskSortLinkAttr {
    pub sortLink: *mut LOS_DL_LIST,
    pub cursor: UINT16,
    pub reserved: UINT16,
}
#[test]
fn bindgen_test_layout_TaskSortLinkAttr() {
    assert_eq!(
        ::std::mem::size_of::<TaskSortLinkAttr>(),
        16usize,
        concat!("Size of: ", stringify!(TaskSortLinkAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<TaskSortLinkAttr>(),
        8usize,
        concat!("Alignment of ", stringify!(TaskSortLinkAttr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskSortLinkAttr>())).sortLink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskSortLinkAttr),
            "::",
            stringify!(sortLink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskSortLinkAttr>())).cursor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskSortLinkAttr),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskSortLinkAttr>())).reserved as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskSortLinkAttr),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @ingroup los_task"]
#[doc = " Time slice structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TaskTimeSlice {
    #[doc = "< Current running task"]
    pub task: *mut LosTaskCB,
    #[doc = "< Expiration time point"]
    pub time: UINT16,
    #[doc = "< Expiration duration"]
    pub tout: UINT16,
}
#[test]
fn bindgen_test_layout_TaskTimeSlice() {
    assert_eq!(
        ::std::mem::size_of::<TaskTimeSlice>(),
        16usize,
        concat!("Size of: ", stringify!(TaskTimeSlice))
    );
    assert_eq!(
        ::std::mem::align_of::<TaskTimeSlice>(),
        8usize,
        concat!("Alignment of ", stringify!(TaskTimeSlice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskTimeSlice>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskTimeSlice),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskTimeSlice>())).time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskTimeSlice),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskTimeSlice>())).tout as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskTimeSlice),
            "::",
            stringify!(tout)
        )
    );
}
#[doc = " @ingroup los_task"]
#[doc = " Time slice structure."]
pub type OsTaskRobin = TaskTimeSlice;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TaskCountInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TaskCountInfo() {
    assert_eq!(
        ::std::mem::size_of::<TaskCountInfo>(),
        1usize,
        concat!("Size of: ", stringify!(TaskCountInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<TaskCountInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(TaskCountInfo))
    );
}
impl TaskCountInfo {
    #[inline]
    pub fn maxCnt(&self) -> UINT8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_maxCnt(&mut self, val: UINT8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn isFull(&self) -> UINT8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isFull(&mut self, val: UINT8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(maxCnt: UINT8, isFull: UINT8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let maxCnt: u8 = unsafe { ::std::mem::transmute(maxCnt) };
            maxCnt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let isFull: u8 = unsafe { ::std::mem::transmute(isFull) };
            isFull as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @ingroup los_task"]
#[doc = " Task switch information structure."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TaskSwitchInfo {
    pub idx: UINT8,
    pub cntInfo: TaskCountInfo,
    pub pid: [UINT16; 10usize],
    pub name: [[CHAR; 32usize]; 10usize],
}
#[test]
fn bindgen_test_layout_TaskSwitchInfo() {
    assert_eq!(
        ::std::mem::size_of::<TaskSwitchInfo>(),
        342usize,
        concat!("Size of: ", stringify!(TaskSwitchInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<TaskSwitchInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(TaskSwitchInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskSwitchInfo>())).idx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskSwitchInfo),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskSwitchInfo>())).cntInfo as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskSwitchInfo),
            "::",
            stringify!(cntInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskSwitchInfo>())).pid as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskSwitchInfo),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TaskSwitchInfo>())).name as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(TaskSwitchInfo),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    pub static mut g_losTask: LosTask;
}
extern "C" {
    #[doc = " @ingroup los_task"]
    #[doc = " Task lock flag."]
    #[doc = ""]
    pub static mut g_losTaskLock: UINT16;
}
extern "C" {
    #[doc = " @ingroup los_task"]
    #[doc = " Maximum number of tasks."]
    #[doc = ""]
    pub static mut g_taskMaxNum: UINT32;
}
extern "C" {
    #[doc = " @ingroup los_task"]
    #[doc = " Idle task ID."]
    #[doc = ""]
    pub static mut g_idleTaskID: UINT32;
}
extern "C" {
    pub static mut g_swtmrTaskID: UINT32;
}
extern "C" {
    #[doc = " @ingroup los_task"]
    #[doc = " Starting address of a task."]
    #[doc = ""]
    pub static mut g_taskCBArray: *mut LosTaskCB;
}
extern "C" {
    #[doc = " @ingroup los_task"]
    #[doc = " Free task linked list."]
    #[doc = ""]
    pub static mut g_losFreeTask: LOS_DL_LIST;
}
extern "C" {
    #[doc = " @ingroup los_task"]
    #[doc = " Circular linked list that stores tasks that are deleted automatically."]
    #[doc = ""]
    pub static mut g_taskRecycleList: LOS_DL_LIST;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Initialization a task."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to initialization a task."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval  UINT32    Initialization result."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn OsTaskInit() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Create idle task."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to create idle task."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval  UINT32   Create result."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn OsIdleTaskCreate() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Check task switch."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to check task switch."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval  None."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn OsTaskSwitchCheck();
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief TaskMonInit."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to taskMonInit."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval  None."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn OsTaskMonInit();
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Task entry."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to task entry."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskID  [IN] Type #UINT32   task id."]
    #[doc = ""]
    #[doc = " @retval  None."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn OsTaskEntry(taskID: UINT32);
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Get the task water line."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to get the task water line."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskID [IN] Type #UINT32 task id."]
    #[doc = ""]
    #[doc = " @retval  UINT32  Task water line."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn OsGetTaskWaterLine(taskID: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Convert task status to string."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to convert task status to string."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  taskStatus [IN] Type #UINT16 task status."]
    #[doc = ""]
    #[doc = " @retval  UINT8 *  String."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn OsConvertTskStatus(taskStatus: UINT16) -> *mut UINT8;
}
extern "C" {
    #[doc = " @ingroup  los_task"]
    #[doc = " @brief Get all task information."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to get all task information."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval  UINT32  All task information."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_task.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn OsGetAllTskInfo() -> UINT32;
}
extern "C" {
    pub fn OsTskUserStackInit(
        stackPtr: *mut ::std::os::raw::c_void,
        userSP: *mut ::std::os::raw::c_void,
        userStackSize: UINT32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OsPmEnterHandlerSet(func: ::std::option::Option<unsafe extern "C" fn()>) -> UINT32;
}
extern "C" {
    pub fn LOS_TaskResRecycle();
}
