/* automatically generated by rust-bindgen 0.59.1 */
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]

pub const OS_LITTLE_ENDIAN: u32 = 4660;
pub const OS_BIG_ENDIAN: u32 = 17185;
pub const OS_BYTE_ORDER: u32 = 4660;
pub const LOS_OK: u32 = 0;
pub const OS_FAIL: u32 = 1;
pub const OS_64BIT_MAX: i32 = -1;
pub const __LIBATOMIC_N_LOCKS: u32 = 16;
pub const OS_SYS_CLOCK: u32 = 1000000;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND: u32 = 100;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND_MINI: u32 = 1000;
pub const LOSCFG_BASE_CORE_TICK_PERIOD_MS: u32 = 10;
pub const LOSCFG_BASE_CORE_TICK_WTIMER: u32 = 0;
pub const LOSCFG_BASE_CORE_TICK_RESPONSE_MAX: u32 = 0;
pub const LOSCFG_PLATFORM_HWI: u32 = 1;
pub const LOSCFG_USE_SYSTEM_DEFINED_INTERRUPT: u32 = 1;
pub const LOSCFG_PLATFORM_HWI_LIMIT: u32 = 32;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO: u32 = 10;
pub const LOSCFG_BASE_CORE_TSK_LIMIT: u32 = 5;
pub const LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE: u32 = 384;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE: u32 = 1024;
pub const LOSCFG_BASE_CORE_TIMESLICE: u32 = 1;
pub const LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT: u32 = 20000;
pub const LOSCFG_BASE_CORE_TSK_MONITOR: u32 = 0;
pub const LOSCFG_BASE_CORE_EXC_TSK_SWITCH: u32 = 0;
pub const LOS_TASK_PRIORITY_HIGHEST: u32 = 0;
pub const LOS_TASK_PRIORITY_LOWEST: u32 = 31;
pub const LOSCFG_BASE_CORE_TASKSTACK_INDEPENDENT: u32 = 0;
pub const LOSCFG_STACK_POINT_ALIGN_SIZE: u32 = 8;
pub const LOSCFG_BASE_IPC_SEM: u32 = 1;
pub const LOSCFG_BASE_IPC_SEM_LIMIT: u32 = 6;
pub const OS_SEM_COUNTING_MAX_COUNT: u32 = 65535;
pub const LOSCFG_BASE_IPC_MUX: u32 = 1;
pub const LOSCFG_BASE_IPC_MUX_LIMIT: u32 = 6;
pub const LOSCFG_BASE_IPC_QUEUE: u32 = 1;
pub const LOSCFG_BASE_IPC_QUEUE_LIMIT: u32 = 6;
pub const LOSCFG_BASE_IPC_STATIC_QUEUE_LIMIT: u32 = 3;
pub const LOSCFG_BASE_CORE_SWTMR: u32 = 1;
pub const LOSCFG_BASE_CORE_SWTMR_LIMIT: u32 = 5;
pub const LOSCFG_BASE_CORE_TSK_SWTMR_STACK_SIZE: u32 = 1024;
pub const LOSCFG_BASE_CORE_SWTMR_ALIGN: u32 = 0;
pub const OS_SWTMR_HANDLE_QUEUE_SIZE: u32 = 5;
pub const LOS_COMMON_DIVISOR: u32 = 10;
pub const LOSCFG_SYS_EXTERNAL_HEAP: u32 = 0;
pub const LOSCFG_SYS_HEAP_SIZE: u32 = 65536;
pub const LOSCFG_MEM_MUL_POOL: u32 = 1;
pub const LOSCFG_MEM_FREE_BY_TASKID: u32 = 0;
pub const LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK: u32 = 0;
pub const LOSCFG_MEM_OMIT_LR_CNT: u32 = 4;
pub const LOSCFG_MEM_RECORD_LR_CNT: u32 = 3;
pub const LOSCFG_MEM_LEAKCHECK_RECORD_MAX_NUM: u32 = 1024;
pub const LOSCFG_MEM_WATERLINE: u32 = 1;
pub const OS_SYS_MEM_NUM: u32 = 20;
pub const OS_SYS_NOCACHEMEM_SIZE: u32 = 0;
pub const LOSCFG_MEM_MUL_REGIONS: u32 = 0;
pub const LOSCFG_EXC_HARDWARE_STACK_PROTECTION: u32 = 0;
pub const CMSIS_OS_VER: u32 = 2;
pub const LOSCFG_KERNEL_PRINTF: u32 = 1;
pub const LOSCFG_MPU_ENABLE: u32 = 0;
pub const LOSCFG_TASK_MEM_USED: u32 = 0;
pub const LOSCFG_PLATFORM_HWI_WITH_ARG: u32 = 0;
pub const LOSCFG_ARCH_HWI_VECTOR_ALIGN: u32 = 256;
pub const LOSCFG_KERNEL_SIGNAL: u32 = 0;
pub const LOSCFG_KERNEL_PM: u32 = 0;
pub const LOSCFG_KERNEL_PM_IDLE: u32 = 0;
pub const LOSCFG_SHELL_STACK_SIZE: u32 = 4096;
pub const TICK_CHECK: u32 = 67108864;
pub const CYCLE_CHECK: u32 = 4294967295;
pub const SHIFT_32_BIT: u32 = 32;
pub const MAX_HOUR: u32 = 24;
pub const MAX_MINUTES: u32 = 60;
pub const MAX_SECONDS: u32 = 60;
pub const MILSEC: u32 = 1000;
pub const RTC_WAKEUPCLOCK_RTCCLK: u32 = 32768;
pub const RTC_WAKEUPCLOCK_RTCCLK_DIV: u32 = 16;
pub const RTC_CALIBRATE_SLEEP_TIME: u32 = 8;
pub const MACHINE_CYCLE_DEALAY_TIMES: u32 = 400;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type INT8 = ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type FLOAT = f32;
pub type DOUBLE = f64;
pub type CHAR = ::std::os::raw::c_char;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type INT64 = ::std::os::raw::c_longlong;
pub type UINTPTR = ::std::os::raw::c_uint;
pub type INTPTR = ::std::os::raw::c_int;
pub type Atomic = INT32;
pub type Atomic64 = INT64;
pub type BOOL = ::std::os::raw::c_uint;
extern "C" {
    pub static mut m_aucSysMem0: *mut UINT8;
}
pub type HWI_HANDLE_T = UINT32;
pub type HWI_PRIOR_T = UINT16;
pub type HWI_MODE_T = UINT16;
pub type HWI_ARG_T = UINT32;
pub type HWI_PROC_FUNC = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIrqParam {
    #[doc = "< The interrupt number"]
    pub swIrq: ::std::os::raw::c_int,
    #[doc = "< The pointer to the device ID that launches the interrupt"]
    pub pDevId: *mut ::std::os::raw::c_void,
    #[doc = "< The interrupt name"]
    pub pName: *const CHAR,
}
#[test]
fn bindgen_test_layout_tagIrqParam() {
    assert_eq!(
        ::std::mem::size_of::<tagIrqParam>(),
        24usize,
        concat!("Size of: ", stringify!(tagIrqParam))
    );
    assert_eq!(
        ::std::mem::align_of::<tagIrqParam>(),
        8usize,
        concat!("Alignment of ", stringify!(tagIrqParam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagIrqParam>())).swIrq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagIrqParam),
            "::",
            stringify!(swIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagIrqParam>())).pDevId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagIrqParam),
            "::",
            stringify!(pDevId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagIrqParam>())).pName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tagIrqParam),
            "::",
            stringify!(pName)
        )
    );
}
pub type HwiIrqParam = tagIrqParam;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HwiControllerOps {
    pub triggerIrq: ::std::option::Option<unsafe extern "C" fn(hwiNum: HWI_HANDLE_T) -> UINT32>,
    pub clearIrq: ::std::option::Option<unsafe extern "C" fn(hwiNum: HWI_HANDLE_T) -> UINT32>,
    pub enableIrq: ::std::option::Option<unsafe extern "C" fn(hwiNum: HWI_HANDLE_T) -> UINT32>,
    pub disableIrq: ::std::option::Option<unsafe extern "C" fn(hwiNum: HWI_HANDLE_T) -> UINT32>,
    pub setIrqPriority: ::std::option::Option<
        unsafe extern "C" fn(hwiNum: HWI_HANDLE_T, priority: UINT8) -> UINT32,
    >,
    pub getCurIrqNum: ::std::option::Option<unsafe extern "C" fn() -> UINT32>,
    pub createIrq: ::std::option::Option<
        unsafe extern "C" fn(hwiNum: HWI_HANDLE_T, hwiPrio: HWI_PRIOR_T) -> UINT32,
    >,
}
#[test]
fn bindgen_test_layout_HwiControllerOps() {
    assert_eq!(
        ::std::mem::size_of::<HwiControllerOps>(),
        56usize,
        concat!("Size of: ", stringify!(HwiControllerOps))
    );
    assert_eq!(
        ::std::mem::align_of::<HwiControllerOps>(),
        8usize,
        concat!("Alignment of ", stringify!(HwiControllerOps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).triggerIrq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(triggerIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).clearIrq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(clearIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).enableIrq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(enableIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).disableIrq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(disableIrq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).setIrqPriority as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(setIrqPriority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).getCurIrqNum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(getCurIrqNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HwiControllerOps>())).createIrq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HwiControllerOps),
            "::",
            stringify!(createIrq)
        )
    );
}
extern "C" {
    pub static mut __stack_chk_guard: UINT32;
}
extern "C" {
    pub fn __stack_chk_fail();
}
extern "C" {
    #[doc = " @ingroup  los_interrupt"]
    #[doc = " @brief Delete hardware interrupt."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to delete hardware interrupt."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The hardware interrupt module is usable only when the configuration item for hardware"]
    #[doc = " interrupt tailoring is enabled.</li>"]
    #[doc = " <li>Hardware interrupt number value range: [OS_USER_HWI_MIN,OS_USER_HWI_MAX]. The value range"]
    #[doc = " applicable for a Cortex-A7 platform is [32,95].</li>"]
    #[doc = " <li>OS_HWI_MAX_NUM specifies the maximum number of interrupts that can be created.</li>"]
    #[doc = " <li>Before executing an interrupt on a platform, refer to the chip manual of the platform.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  hwiNum   [IN] Type#HWI_HANDLE_T: hardware interrupt number. The value range applicable"]
    #[doc = "                       for a Cortex-A7 platform is [32,95]."]
    #[doc = " @param  irqParam [IN] Type #HwiIrqParam *. ID of hardware interrupt which will base on"]
    #[doc = "                                                when delete the hardware interrupt."]
    #[doc = " @retval #OS_ERRNO_HWI_NUM_INVALID              0x02000900: Invalid interrupt number."]
    #[doc = " @retval #LOS_OK                                0         : The interrupt is successfully delete."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_interrupt.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn ArchHwiDelete(hwiNum: HWI_HANDLE_T, irqParam: *mut HwiIrqParam) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup  los_interrupt"]
    #[doc = " @brief Create a hardware interrupt."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to configure a hardware interrupt and register a hardware interrupt handling function."]
    #[doc = ""]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The hardware interrupt module is usable only when the configuration item for hardware"]
    #[doc = " interrupt tailoring is enabled.</li>"]
    #[doc = " <li>Hardware interrupt number value range: [OS_USER_HWI_MIN,OS_USER_HWI_MAX]. The value range"]
    #[doc = " applicable for a Cortex-A7 platform is [32,95].</li>"]
    #[doc = " <li>OS_HWI_MAX_NUM specifies the maximum number of interrupts that can be created.</li>"]
    #[doc = " <li>Before executing an interrupt on a platform, refer to the chip manual of the platform.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  hwiNum   [IN] Type#HWI_HANDLE_T: hardware interrupt number. The value range applicable for a"]
    #[doc = "                       Cortex-A7 platform is [32,95]."]
    #[doc = " @param  hwiPrio  [IN] Type#HWI_PRIOR_T: hardware interrupt priority. Ignore this parameter temporarily."]
    #[doc = " @param  mode     [IN] Type#HWI_MODE_T: hardware interrupt mode. Ignore this parameter temporarily."]
    #[doc = " @param  handler  [IN] Type#HWI_PROC_FUNC: interrupt handler used when a hardware interrupt is triggered."]
    #[doc = " @param  irqParam [IN] Type#HwiIrqParam: input parameter of the interrupt"]
    #[doc = "                                         handler used when a hardware interrupt is triggered."]
    #[doc = ""]
    #[doc = " @retval #OS_ERRNO_HWI_PROC_FUNC_NULL               0x02000901: Null hardware interrupt handling function."]
    #[doc = " @retval #OS_ERRNO_HWI_NUM_INVALID                  0x02000900: Invalid interrupt number."]
    #[doc = " @retval #OS_ERRNO_HWI_NO_MEMORY                    0x02000903: Insufficient memory for hardware interrupt creation."]
    #[doc = " @retval #OS_ERRNO_HWI_ALREADY_CREATED              0x02000904: The interrupt handler being created has"]
    #[doc = "                                                                already been created."]
    #[doc = " @retval #LOS_OK                                    0         : The interrupt is successfully created."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_interrupt.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn ArchHwiCreate(
        hwiNum: HWI_HANDLE_T,
        hwiPrio: HWI_PRIOR_T,
        mode: HWI_MODE_T,
        handler: HWI_PROC_FUNC,
        irqParam: *mut HwiIrqParam,
    ) -> UINT32;
}
extern "C" {
    pub fn ArchIsIntActive() -> UINT32;
}
extern "C" {
    pub fn ArchIntLock() -> UINT32;
}
extern "C" {
    pub fn ArchIntUnLock() -> UINT32;
}
extern "C" {
    pub fn ArchIntRestore(intSave: UINT32);
}
extern "C" {
    pub fn ArchIntTrigger(hwiNum: HWI_HANDLE_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntEnable(hwiNum: HWI_HANDLE_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntDisable(hwiNum: HWI_HANDLE_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntClear(hwiNum: HWI_HANDLE_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntSetPriority(hwiNum: HWI_HANDLE_T, priority: HWI_PRIOR_T) -> UINT32;
}
extern "C" {
    pub fn ArchIntCurIrqNum() -> UINT32;
}
extern "C" {
    pub fn ArchIntOpsGet() -> *mut HwiControllerOps;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArchTickTimer {
    pub freq: UINT32,
    pub irqNum: INT32,
    pub periodMax: UINT64,
    pub init: ::std::option::Option<unsafe extern "C" fn(tickHandler: HWI_PROC_FUNC) -> UINT32>,
    pub getCycle: ::std::option::Option<unsafe extern "C" fn(period: *mut UINT32) -> UINT64>,
    pub reload: ::std::option::Option<unsafe extern "C" fn(time: UINT64) -> UINT64>,
    pub lock: ::std::option::Option<unsafe extern "C" fn()>,
    pub unlock: ::std::option::Option<unsafe extern "C" fn()>,
    pub tickHandler: HWI_PROC_FUNC,
}
#[test]
fn bindgen_test_layout_ArchTickTimer() {
    assert_eq!(
        ::std::mem::size_of::<ArchTickTimer>(),
        64usize,
        concat!("Size of: ", stringify!(ArchTickTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<ArchTickTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(ArchTickTimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).freq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).irqNum as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(irqNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).periodMax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(periodMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).getCycle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(getCycle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).reload as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(reload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).lock as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).unlock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArchTickTimer>())).tickHandler as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ArchTickTimer),
            "::",
            stringify!(tickHandler)
        )
    );
}
extern "C" {
    pub fn ArchEnterSleep() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_timer"]
    #[doc = " @brief Get tick timer control block."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to get tick timer control block."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @retval #tick timer control block"]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_timer.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn ArchSysTickTimerGet() -> *mut ArchTickTimer;
}
extern "C" {
    pub fn ArchInit();
}
