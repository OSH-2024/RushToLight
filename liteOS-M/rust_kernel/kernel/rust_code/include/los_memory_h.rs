/* automatically generated by rust-bindgen 0.59.1 */
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]

pub const OS_LITTLE_ENDIAN: u32 = 4660;
pub const OS_BIG_ENDIAN: u32 = 17185;
pub const OS_BYTE_ORDER: u32 = 4660;
pub const LOS_OK: u32 = 0;
pub const OS_FAIL: u32 = 1;
pub const OS_64BIT_MAX: i32 = -1;
pub const __LIBATOMIC_N_LOCKS: u32 = 16;
pub const OS_SYS_CLOCK: u32 = 1000000;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND: u32 = 100;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND_MINI: u32 = 1000;
pub const LOSCFG_BASE_CORE_TICK_PERIOD_MS: u32 = 10;
pub const LOSCFG_BASE_CORE_TICK_WTIMER: u32 = 0;
pub const LOSCFG_BASE_CORE_TICK_RESPONSE_MAX: u32 = 0;
pub const LOSCFG_PLATFORM_HWI: u32 = 1;
pub const LOSCFG_USE_SYSTEM_DEFINED_INTERRUPT: u32 = 1;
pub const LOSCFG_PLATFORM_HWI_LIMIT: u32 = 32;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO: u32 = 10;
pub const LOSCFG_BASE_CORE_TSK_LIMIT: u32 = 5;
pub const LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE: u32 = 384;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE: u32 = 1024;
pub const LOSCFG_BASE_CORE_TIMESLICE: u32 = 1;
pub const LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT: u32 = 20000;
pub const LOSCFG_BASE_CORE_TSK_MONITOR: u32 = 0;
pub const LOSCFG_BASE_CORE_EXC_TSK_SWITCH: u32 = 0;
pub const LOS_TASK_PRIORITY_HIGHEST: u32 = 0;
pub const LOS_TASK_PRIORITY_LOWEST: u32 = 31;
pub const LOSCFG_BASE_CORE_TASKSTACK_INDEPENDENT: u32 = 0;
pub const LOSCFG_STACK_POINT_ALIGN_SIZE: u32 = 8;
pub const LOSCFG_BASE_IPC_SEM: u32 = 1;
pub const LOSCFG_BASE_IPC_SEM_LIMIT: u32 = 6;
pub const OS_SEM_COUNTING_MAX_COUNT: u32 = 65535;
pub const LOSCFG_BASE_IPC_MUX: u32 = 1;
pub const LOSCFG_BASE_IPC_MUX_LIMIT: u32 = 6;
pub const LOSCFG_BASE_IPC_QUEUE: u32 = 1;
pub const LOSCFG_BASE_IPC_QUEUE_LIMIT: u32 = 6;
pub const LOSCFG_BASE_IPC_STATIC_QUEUE_LIMIT: u32 = 3;
pub const LOSCFG_BASE_CORE_SWTMR: u32 = 1;
pub const LOSCFG_BASE_CORE_SWTMR_LIMIT: u32 = 5;
pub const LOSCFG_BASE_CORE_TSK_SWTMR_STACK_SIZE: u32 = 1024;
pub const LOSCFG_BASE_CORE_SWTMR_ALIGN: u32 = 0;
pub const OS_SWTMR_HANDLE_QUEUE_SIZE: u32 = 5;
pub const LOS_COMMON_DIVISOR: u32 = 10;
pub const LOSCFG_SYS_EXTERNAL_HEAP: u32 = 0;
pub const LOSCFG_SYS_HEAP_SIZE: u32 = 65536;
pub const LOSCFG_MEM_MUL_POOL: u32 = 1;
pub const LOSCFG_MEM_FREE_BY_TASKID: u32 = 0;
pub const LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK: u32 = 0;
pub const LOSCFG_MEM_OMIT_LR_CNT: u32 = 4;
pub const LOSCFG_MEM_RECORD_LR_CNT: u32 = 3;
pub const LOSCFG_MEM_LEAKCHECK_RECORD_MAX_NUM: u32 = 1024;
pub const LOSCFG_MEM_WATERLINE: u32 = 1;
pub const OS_SYS_MEM_NUM: u32 = 20;
pub const OS_SYS_NOCACHEMEM_SIZE: u32 = 0;
pub const LOSCFG_MEM_MUL_REGIONS: u32 = 0;
pub const LOSCFG_EXC_HARDWARE_STACK_PROTECTION: u32 = 0;
pub const CMSIS_OS_VER: u32 = 2;
pub const LOSCFG_KERNEL_PRINTF: u32 = 1;
pub const LOSCFG_MPU_ENABLE: u32 = 0;
pub const LOSCFG_TASK_MEM_USED: u32 = 0;
pub const LOSCFG_PLATFORM_HWI_WITH_ARG: u32 = 0;
pub const LOSCFG_ARCH_HWI_VECTOR_ALIGN: u32 = 256;
pub const LOSCFG_KERNEL_SIGNAL: u32 = 0;
pub const LOSCFG_KERNEL_PM: u32 = 0;
pub const LOSCFG_KERNEL_PM_IDLE: u32 = 0;
pub const LOSCFG_SHELL_STACK_SIZE: u32 = 4096;
pub const LOG_EMG_LEVEL: u32 = 0;
pub const LOG_COMMON_LEVEL: u32 = 1;
pub const LOG_ERR_LEVEL: u32 = 2;
pub const LOG_WARN_LEVEL: u32 = 3;
pub const LOG_INFO_LEVEL: u32 = 4;
pub const LOG_DEBUG_LEVEL: u32 = 5;
pub const PRINT_LEVEL: u32 = 2;
pub const OS_MEM_SLI: u32 = 3;
pub const OS_MEM_SMALL_BUCKET_COUNT: u32 = 31;
pub const OS_MEM_SMALL_BUCKET_MAX_SIZE: u32 = 128;
pub const OS_MEM_LARGE_BUCKET_COUNT: u32 = 24;
pub const OS_MEM_LARGE_START_BUCKET: u32 = 7;
pub const OS_MEM_FREE_LIST_COUNT: u32 = 223;
pub const OS_MEM_BITMAP_WORDS: u32 = 7;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type INT8 = ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type FLOAT = f32;
pub type DOUBLE = f64;
pub type CHAR = ::std::os::raw::c_char;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type INT64 = ::std::os::raw::c_longlong;
pub type UINTPTR = ::std::os::raw::c_uint;
pub type INTPTR = ::std::os::raw::c_int;
pub type Atomic = INT32;
pub type Atomic64 = INT64;
pub type BOOL = ::std::os::raw::c_uint;
extern "C" {
    pub static mut m_aucSysMem0: *mut UINT8;
}
#[doc = " @ingroup los_list"]
#[doc = " Structure of a node in a doubly linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOS_DL_LIST {
    #[doc = "< Current node's pointer to the previous node"]
    pub pstPrev: *mut LOS_DL_LIST,
    #[doc = "< Current node's pointer to the next node"]
    pub pstNext: *mut LOS_DL_LIST,
}
#[test]
fn bindgen_test_layout_LOS_DL_LIST() {
    assert_eq!(
        ::std::mem::size_of::<LOS_DL_LIST>(),
        16usize,
        concat!("Size of: ", stringify!(LOS_DL_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<LOS_DL_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(LOS_DL_LIST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_DL_LIST>())).pstPrev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_DL_LIST),
            "::",
            stringify!(pstPrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_DL_LIST>())).pstNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_DL_LIST),
            "::",
            stringify!(pstNext)
        )
    );
}
pub const EXC_TYPE_EXC_REBOOT: EXC_TYPE = 0;
pub const EXC_TYPE_EXC_ASSERT: EXC_TYPE = 1;
pub const EXC_TYPE_EXC_PANIC: EXC_TYPE = 2;
pub const EXC_TYPE_EXC_STACKOVERFLOW: EXC_TYPE = 3;
pub const EXC_TYPE_EXC_INTERRUPT: EXC_TYPE = 4;
pub const EXC_TYPE_EXC_TYPE_END: EXC_TYPE = 5;
pub type EXC_TYPE = ::std::os::raw::c_uint;
pub type ExcHookFn = ::std::option::Option<unsafe extern "C" fn(excType: EXC_TYPE)>;
extern "C" {
    pub fn OsExcHookRegister(excHookFn: ExcHookFn);
}
extern "C" {
    pub fn OsDoExcHook(excType: EXC_TYPE);
}
pub const LogModuleType_LOG_MODULE_KERNEL: LogModuleType = 0;
pub const LogModuleType_LOG_MODULE_FS: LogModuleType = 1;
pub const LogModuleType_LOS_MODULE_OTHERS: LogModuleType = 2;
pub type LogModuleType = ::std::os::raw::c_uint;
extern "C" {
    pub fn printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OsLogLevelCheck(level: INT32) -> INT32;
}
pub type BACK_TRACE_HOOK = ::std::option::Option<
    unsafe extern "C" fn(LR: *mut UINTPTR, LRSize: UINT32, jumpCount: UINT32, SP: UINTPTR),
>;
extern "C" {
    pub fn OsBackTraceHookSet(hook: BACK_TRACE_HOOK);
}
extern "C" {
    pub fn OsBackTraceHookCall(LR: *mut UINTPTR, LRSize: UINT32, jumpCount: UINT32, SP: UINTPTR);
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Deinitialize dynamic memory."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to deinitialize the dynamic memory of a doubly linked list.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param pool          [IN] Starting address of memory."]
    #[doc = ""]
    #[doc = " @retval #OS_ERROR   The dynamic memory fails to be deinitialized."]
    #[doc = " @retval #LOS_OK     The dynamic memory is successfully deinitialized."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul>"]
    #[doc = " <li>los_memory.h: the header file that contains the API declaration.</li>"]
    #[doc = " </ul>"]
    #[doc = " @see None."]
    pub fn LOS_MemDeInit(pool: *mut ::std::os::raw::c_void) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Print information about all pools."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to print information about all pools.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @retval #UINT32   The pool number."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul>"]
    #[doc = " <li>los_memory.h: the header file that contains the API declaration.</li>"]
    #[doc = " </ul>"]
    #[doc = " @see None."]
    pub fn LOS_MemPoolList() -> UINT32;
}
#[doc = " @ingroup los_memory"]
#[doc = " Memory pool extern information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOS_MEM_POOL_STATUS {
    pub totalUsedSize: UINT32,
    pub totalFreeSize: UINT32,
    pub maxFreeNodeSize: UINT32,
    pub usedNodeNum: UINT32,
    pub freeNodeNum: UINT32,
    pub usageWaterLine: UINT32,
}
#[test]
fn bindgen_test_layout_LOS_MEM_POOL_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<LOS_MEM_POOL_STATUS>(),
        24usize,
        concat!("Size of: ", stringify!(LOS_MEM_POOL_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<LOS_MEM_POOL_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(LOS_MEM_POOL_STATUS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LOS_MEM_POOL_STATUS>())).totalUsedSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_MEM_POOL_STATUS),
            "::",
            stringify!(totalUsedSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LOS_MEM_POOL_STATUS>())).totalFreeSize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_MEM_POOL_STATUS),
            "::",
            stringify!(totalFreeSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LOS_MEM_POOL_STATUS>())).maxFreeNodeSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_MEM_POOL_STATUS),
            "::",
            stringify!(maxFreeNodeSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_MEM_POOL_STATUS>())).usedNodeNum as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_MEM_POOL_STATUS),
            "::",
            stringify!(usedNodeNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_MEM_POOL_STATUS>())).freeNodeNum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_MEM_POOL_STATUS),
            "::",
            stringify!(freeNodeNum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LOS_MEM_POOL_STATUS>())).usageWaterLine as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_MEM_POOL_STATUS),
            "::",
            stringify!(usageWaterLine)
        )
    );
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Initialize dynamic memory."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to initialize the dynamic memory of a doubly linked list.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The size parameter value should match the following two conditions :"]
    #[doc = " 1) Be less than or equal to the Memory pool size;"]
    #[doc = " 2) Be greater than the size of OS_MEM_MIN_POOL_SIZE.</li>"]
    #[doc = " <li>Call this API when dynamic memory needs to be initialized during the startup of Huawei LiteOS.</li>"]
    #[doc = " <li>The parameter input must be four byte-aligned.</li>"]
    #[doc = " <li>The init area [pool, pool + size] should not conflict with other pools.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param pool         [IN] Starting address of memory."]
    #[doc = " @param size         [IN] Memory size."]
    #[doc = ""]
    #[doc = " @retval #OS_ERROR   The dynamic memory fails to be initialized."]
    #[doc = " @retval #LOS_OK     The dynamic memory is successfully initialized."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul>"]
    #[doc = " <li>los_memory.h: the header file that contains the API declaration.</li>"]
    #[doc = " </ul>"]
    #[doc = " @see None."]
    pub fn LOS_MemInit(pool: *mut ::std::os::raw::c_void, size: UINT32) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Allocate dynamic memory."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to allocate a memory block of which the size is specified.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The input pool parameter must be initialized via func LOS_MemInit.</li>"]
    #[doc = " <li>The size of the input parameter size can not be greater than the memory pool size that specified at the second"]
    #[doc = " input parameter of LOS_MemInit.</li>"]
    #[doc = " <li>The size of the input parameter size must be four byte-aligned.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  pool    [IN] Pointer to the memory pool that contains the memory block to be allocated."]
    #[doc = " @param  size    [IN] Size of the memory block to be allocated (unit: byte)."]
    #[doc = ""]
    #[doc = " @retval #NULL          The memory fails to be allocated."]
    #[doc = " @retval #VOID*         The memory is successfully allocated with the starting address of the allocated memory block"]
    #[doc = "                        returned."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_memory.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_MemRealloc | LOS_MemAllocAlign | LOS_MemFree"]
    pub fn LOS_MemAlloc(
        pool: *mut ::std::os::raw::c_void,
        size: UINT32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Free dynamic memory."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <li>This API is used to free specified dynamic memory that has been allocated.</li>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The input pool parameter must be initialized via func LOS_MemInit.</li>"]
    #[doc = " <li>The input ptr parameter must be allocated by LOS_MemAlloc or LOS_MemAllocAlign or LOS_MemRealloc.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  pool  [IN] Pointer to the memory pool that contains the dynamic memory block to be freed."]
    #[doc = " @param  ptr   [IN] Starting address of the memory block to be freed."]
    #[doc = ""]
    #[doc = " @retval #LOS_NOK          The memory block fails to be freed because the starting address of the memory block is"]
    #[doc = "                           invalid, or the memory overwriting occurs."]
    #[doc = " @retval #LOS_OK           The memory block is successfully freed."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_memory.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_MemAlloc | LOS_MemRealloc | LOS_MemAllocAlign"]
    pub fn LOS_MemFree(
        pool: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
    ) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Re-allocate a memory block."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to allocate a new memory block of which the size is specified by size if the original memory"]
    #[doc = " block size is insufficient. The new memory block will copy the data in the original memory block of which the"]
    #[doc = " address is specified by ptr. The size of the new memory block determines the maximum size of data to be copied."]
    #[doc = " After the new memory block is created, the original one is freed.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The input pool parameter must be initialized via func LOS_MemInit.</li>"]
    #[doc = " <li>The input ptr parameter must be allocated by LOS_MemAlloc or LOS_MemAllocAlign.</li>"]
    #[doc = " <li>The size of the input parameter size can not be greater than the memory pool size that specified at the second"]
    #[doc = " input parameter of LOS_MemInit.</li>"]
    #[doc = " <li>The size of the input parameter size must be aligned as follows: 1) if the ptr is allocated by LOS_MemAlloc,"]
    #[doc = " it must be four byte-aligned; 2) if the ptr is allocated by LOS_MemAllocAlign, it must be aligned with the size of"]
    #[doc = " the input parameter boundary of LOS_MemAllocAlign.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  pool     [IN] Pointer to the memory pool that contains the original and new memory blocks."]
    #[doc = " @param  ptr      [IN] Address of the original memory block."]
    #[doc = " @param  size     [IN] Size of the new memory block."]
    #[doc = ""]
    #[doc = " @retval #NULL    The memory fails to be re-allocated."]
    #[doc = " @retval #VOID*   The memory is successfully re-allocated with the starting address of the new memory block returned."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_memory.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_MemAlloc | LOS_MemAllocAlign | LOS_MemFree"]
    pub fn LOS_MemRealloc(
        pool: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
        size: UINT32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Allocate aligned memory."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to allocate memory blocks of specified size and of which the starting addresses are aligned on"]
    #[doc = " a specified boundary.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The input pool parameter must be initialized via func LOS_MemInit.</li>"]
    #[doc = " <li>The size of the input parameter size can not be greater than the memory pool size that specified at the second"]
    #[doc = " input parameter of LOS_MemInit.</li>"]
    #[doc = " <li>The alignment parameter value must be a power of 2 with the minimum value being 4.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  pool      [IN] Pointer to the memory pool that contains the memory blocks to be allocated."]
    #[doc = " @param  size      [IN] Size of the memory to be allocated."]
    #[doc = " @param  boundary  [IN] Boundary on which the memory is aligned."]
    #[doc = ""]
    #[doc = " @retval #NULL    The memory fails to be allocated."]
    #[doc = " @retval #VOID*   The memory is successfully allocated with the starting address of the allocated memory returned."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_memory.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see LOS_MemAlloc | LOS_MemRealloc | LOS_MemFree"]
    pub fn LOS_MemAllocAlign(
        pool: *mut ::std::os::raw::c_void,
        size: UINT32,
        boundary: UINT32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Get the size of memory pool's size."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to get the size of memory pool' total size.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The input pool parameter must be initialized via func LOS_MemInit.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  pool           [IN] A pointer pointed to the memory pool."]
    #[doc = ""]
    #[doc = " @retval #LOS_NOK        The incoming parameter pool is NULL."]
    #[doc = " @retval #UINT32         The size of the memory pool."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_memory.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn LOS_MemPoolSizeGet(pool: *const ::std::os::raw::c_void) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Get the size of memory totally used."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to get the size of memory totally used in memory pool.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The input pool parameter must be initialized via func LOS_MemInit.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  pool           [IN] A pointer pointed to the memory pool."]
    #[doc = ""]
    #[doc = " @retval #LOS_NOK        The incoming parameter pool is NULL."]
    #[doc = " @retval #UINT32         The size of the memory pool used."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_memory.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn LOS_MemTotalUsedGet(pool: *mut ::std::os::raw::c_void) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Get the information of memory pool."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to get the information of memory pool.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The input pool parameter must be initialized via func LOS_MemInit.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  pool                 [IN] A pointer pointed to the memory pool."]
    #[doc = " @param  poolStatus           [IN] A pointer for storage the pool status"]
    #[doc = ""]
    #[doc = " @retval #LOS_NOK           The incoming parameter pool is NULL or invalid."]
    #[doc = " @retval #LOS_OK            Success to get memory information."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_memory.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn LOS_MemInfoGet(
        pool: *mut ::std::os::raw::c_void,
        poolStatus: *mut LOS_MEM_POOL_STATUS,
    ) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Get the number of free node in every size."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to get the number of free node in every size.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The input pool parameter must be initialized via func LOS_MemInit.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  pool               [IN] A pointer pointed to the memory pool."]
    #[doc = ""]
    #[doc = " @retval #LOS_NOK           The incoming parameter pool is NULL."]
    #[doc = " @retval #UINT32            The address of the last used node that casts to UINT32."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_memory.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn LOS_MemFreeNodeShow(pool: *mut ::std::os::raw::c_void) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_memory"]
    #[doc = " @brief Check the memory pool integrity."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " <ul>"]
    #[doc = " <li>This API is used to check the memory pool integrity.</li>"]
    #[doc = " </ul>"]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>The input pool parameter must be initialized via func LOS_MemInit.</li>"]
    #[doc = " <li>LOS_MemIntegrityCheck will be called by malloc function when the macro of LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK"]
    #[doc = " is defined in LiteOS.</li>"]
    #[doc = " <li>LOS_MemIntegrityCheck function can be called by user anytime.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  pool              [IN] A pointer pointed to the memory pool."]
    #[doc = ""]
    #[doc = " @retval #LOS_NOK           The memory pool (pool) is impaired."]
    #[doc = " @retval #LOS_OK            The memory pool (pool) is integrated."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_memory.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None."]
    pub fn LOS_MemIntegrityCheck(pool: *const ::std::os::raw::c_void) -> UINT32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OsMemNodeHead {
    pub ptr: OsMemNodeHead__bindgen_ty_1,
    pub linkReg: [usize; LOSCFG_MEM_RECORD_LR_CNT as usize], // LOSCFG_MEM_LEAKCHECK = 1 时生效
    pub sizeAndFlag: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OsMemNodeHead__bindgen_ty_1 {
    pub prev: *mut OsMemNodeHead,
    pub next: *mut OsMemNodeHead,
}
#[test]
fn bindgen_test_layout_OsMemNodeHead__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<OsMemNodeHead__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(OsMemNodeHead__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<OsMemNodeHead__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(OsMemNodeHead__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OsMemNodeHead__bindgen_ty_1>())).prev as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemNodeHead__bindgen_ty_1),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OsMemNodeHead__bindgen_ty_1>())).next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemNodeHead__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
}
#[test]
fn bindgen_test_layout_OsMemNodeHead() {
    assert_eq!(
        ::std::mem::size_of::<OsMemNodeHead>(),
        16usize,
        concat!("Size of: ", stringify!(OsMemNodeHead))
    );
    assert_eq!(
        ::std::mem::align_of::<OsMemNodeHead>(),
        8usize,
        concat!("Alignment of ", stringify!(OsMemNodeHead))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemNodeHead>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemNodeHead),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemNodeHead>())).sizeAndFlag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemNodeHead),
            "::",
            stringify!(sizeAndFlag)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct OsMemFreeNodeHead {
    pub header: OsMemNodeHead,
    pub prev: *mut OsMemFreeNodeHead,
    pub next: *mut OsMemFreeNodeHead,
}
#[test]
fn bindgen_test_layout_OsMemFreeNodeHead() {
    assert_eq!(
        ::std::mem::size_of::<OsMemFreeNodeHead>(),
        32usize,
        concat!("Size of: ", stringify!(OsMemFreeNodeHead))
    );
    assert_eq!(
        ::std::mem::align_of::<OsMemFreeNodeHead>(),
        8usize,
        concat!("Alignment of ", stringify!(OsMemFreeNodeHead))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemFreeNodeHead>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemFreeNodeHead),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemFreeNodeHead>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemFreeNodeHead),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemFreeNodeHead>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemFreeNodeHead),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OsMemPoolInfo {
    pub pool: *mut ::std::os::raw::c_void,
    pub totalSize: UINT32,
    pub attr: UINT32,
    pub waterLine: UINT32,
    pub curUsedSize: UINT32,
}
#[test]
fn bindgen_test_layout_OsMemPoolInfo() {
    assert_eq!(
        ::std::mem::size_of::<OsMemPoolInfo>(),
        24usize,
        concat!("Size of: ", stringify!(OsMemPoolInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OsMemPoolInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OsMemPoolInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemPoolInfo>())).pool as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemPoolInfo),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemPoolInfo>())).totalSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemPoolInfo),
            "::",
            stringify!(totalSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemPoolInfo>())).attr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemPoolInfo),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemPoolInfo>())).waterLine as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemPoolInfo),
            "::",
            stringify!(waterLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemPoolInfo>())).curUsedSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemPoolInfo),
            "::",
            stringify!(curUsedSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OsMemPoolHead {
    pub info: OsMemPoolInfo,
    pub freeListBitmap: [UINT32; 7usize],
    pub freeList: [*mut OsMemFreeNodeHead; 223usize],
    pub nextPool: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_OsMemPoolHead() {
    assert_eq!(
        ::std::mem::size_of::<OsMemPoolHead>(),
        1848usize,
        concat!("Size of: ", stringify!(OsMemPoolHead))
    );
    assert_eq!(
        ::std::mem::align_of::<OsMemPoolHead>(),
        8usize,
        concat!("Alignment of ", stringify!(OsMemPoolHead))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemPoolHead>())).info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemPoolHead),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemPoolHead>())).freeListBitmap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemPoolHead),
            "::",
            stringify!(freeListBitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemPoolHead>())).freeList as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemPoolHead),
            "::",
            stringify!(freeList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OsMemPoolHead>())).nextPool as *const _ as usize },
        1840usize,
        concat!(
            "Offset of field: ",
            stringify!(OsMemPoolHead),
            "::",
            stringify!(nextPool)
        )
    );
}
extern "C" {
    pub fn LOS_MemUnlockEnable(pool: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn OsMemSystemInit() -> UINT32;
}
extern "C" {
    pub fn OsTaskMemUsed(
        pool: *mut ::std::os::raw::c_void,
        tskMemInfoBuf: *mut UINT32,
        tskMemInfoCnt: UINT32,
    );
}
