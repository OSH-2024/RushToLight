/* automatically generated by rust-bindgen 0.59.1 */
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]

pub const OS_LITTLE_ENDIAN: u32 = 4660;
pub const OS_BIG_ENDIAN: u32 = 17185;
pub const OS_BYTE_ORDER: u32 = 4660;
pub const LOS_OK: u32 = 0;
pub const OS_FAIL: u32 = 1;
pub const OS_64BIT_MAX: i32 = -1;
pub const __LIBATOMIC_N_LOCKS: u32 = 16;
pub const COMMON_ERRMODE: u32 = 3;
pub const FREE_ERRORMODE: u32 = 2;
pub const STORE_ERRMODE: u32 = 1;
pub const LOAD_ERRMODE: u32 = 0;
pub const LMS_SHADOW_BITS_PER_CELL: u32 = 2;
pub const LMS_MEM_BYTES_PER_SHADOW_CELL: u32 = 4;
pub const LMS_SHADOW_U8_CELL_NUM: u32 = 4;
pub const LMS_SHADOW_U8_REFER_BYTES: u32 = 16;
pub const LMS_SHADOW_ACCESSIBLE: u32 = 0;
pub const LMS_SHADOW_AFTERFREE: u32 = 3;
pub const LMS_SHADOW_REDZONE: u32 = 2;
pub const LMS_SHADOW_PAINT: u32 = 1;
pub const LMS_SHADOW_MASK: u32 = 3;
pub const LMS_SHADOW_ACCESSIBLE_U8: u32 = 0;
pub const LMS_SHADOW_AFTERFREE_U8: u32 = 255;
pub const LMS_SHADOW_REDZONE_U8: u32 = 170;
pub const LMS_SHADOW_MASK_U8: u32 = 255;
pub const LMS_SHADOW_PAINT_U8: u32 = 85;
pub const MEM_REGION_SIZE_1: u32 = 1;
pub const MEM_REGION_SIZE_2: u32 = 2;
pub const MEM_REGION_SIZE_4: u32 = 4;
pub const MEM_REGION_SIZE_8: u32 = 8;
pub const MEM_REGION_SIZE_16: u32 = 16;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type INT8 = ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type FLOAT = f32;
pub type DOUBLE = f64;
pub type CHAR = ::std::os::raw::c_char;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type INT64 = ::std::os::raw::c_longlong;
pub type UINTPTR = ::std::os::raw::c_uint;
pub type INTPTR = ::std::os::raw::c_int;
pub type Atomic = INT32;
pub type Atomic64 = INT64;
pub type BOOL = ::std::os::raw::c_uint;
#[doc = " @ingroup los_list"]
#[doc = " Structure of a node in a doubly linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOS_DL_LIST {
    #[doc = "< Current node's pointer to the previous node"]
    pub pstPrev: *mut LOS_DL_LIST,
    #[doc = "< Current node's pointer to the next node"]
    pub pstNext: *mut LOS_DL_LIST,
}
#[test]
fn bindgen_test_layout_LOS_DL_LIST() {
    assert_eq!(
        ::std::mem::size_of::<LOS_DL_LIST>(),
        16usize,
        concat!("Size of: ", stringify!(LOS_DL_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<LOS_DL_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(LOS_DL_LIST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_DL_LIST>())).pstPrev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_DL_LIST),
            "::",
            stringify!(pstPrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_DL_LIST>())).pstNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_DL_LIST),
            "::",
            stringify!(pstNext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LmsMemListNode {
    pub node: LOS_DL_LIST,
    pub used: UINT32,
    pub poolAddr: UINTPTR,
    pub poolSize: UINT32,
    pub shadowStart: UINTPTR,
    pub shadowSize: UINT32,
}
#[test]
fn bindgen_test_layout_LmsMemListNode() {
    assert_eq!(
        ::std::mem::size_of::<LmsMemListNode>(),
        40usize,
        concat!("Size of: ", stringify!(LmsMemListNode))
    );
    assert_eq!(
        ::std::mem::align_of::<LmsMemListNode>(),
        8usize,
        concat!("Alignment of ", stringify!(LmsMemListNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsMemListNode>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsMemListNode),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsMemListNode>())).used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsMemListNode),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsMemListNode>())).poolAddr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsMemListNode),
            "::",
            stringify!(poolAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsMemListNode>())).poolSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsMemListNode),
            "::",
            stringify!(poolSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsMemListNode>())).shadowStart as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsMemListNode),
            "::",
            stringify!(shadowStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsMemListNode>())).shadowSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsMemListNode),
            "::",
            stringify!(shadowSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LmsAddrInfo {
    pub memAddr: UINTPTR,
    pub shadowAddr: UINTPTR,
    pub shadowOffset: UINT32,
    pub shadowValue: UINT32,
}
#[test]
fn bindgen_test_layout_LmsAddrInfo() {
    assert_eq!(
        ::std::mem::size_of::<LmsAddrInfo>(),
        16usize,
        concat!("Size of: ", stringify!(LmsAddrInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<LmsAddrInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(LmsAddrInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsAddrInfo>())).memAddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsAddrInfo),
            "::",
            stringify!(memAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsAddrInfo>())).shadowAddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsAddrInfo),
            "::",
            stringify!(shadowAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsAddrInfo>())).shadowOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsAddrInfo),
            "::",
            stringify!(shadowOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsAddrInfo>())).shadowValue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsAddrInfo),
            "::",
            stringify!(shadowValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LmsHook {
    pub init: ::std::option::Option<
        unsafe extern "C" fn(pool: *const ::std::os::raw::c_void, size: UINT32) -> UINT32,
    >,
    pub deInit: ::std::option::Option<unsafe extern "C" fn(pool: *const ::std::os::raw::c_void)>,
    pub mallocMark: ::std::option::Option<
        unsafe extern "C" fn(
            curNodeStart: *const ::std::os::raw::c_void,
            nextNodeStart: *const ::std::os::raw::c_void,
            nodeHeadSize: UINT32,
        ),
    >,
    pub freeMark: ::std::option::Option<
        unsafe extern "C" fn(
            curNodeStart: *const ::std::os::raw::c_void,
            nextNodeStart: *const ::std::os::raw::c_void,
            nodeHeadSize: UINT32,
        ),
    >,
    pub simpleMark: ::std::option::Option<
        unsafe extern "C" fn(startAddr: UINTPTR, endAddr: UINTPTR, value: UINT32),
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(checkAddr: UINTPTR, isFreeCheck: BOOL)>,
}
#[test]
fn bindgen_test_layout_LmsHook() {
    assert_eq!(
        ::std::mem::size_of::<LmsHook>(),
        48usize,
        concat!("Size of: ", stringify!(LmsHook))
    );
    assert_eq!(
        ::std::mem::align_of::<LmsHook>(),
        8usize,
        concat!("Alignment of ", stringify!(LmsHook))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsHook>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsHook),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsHook>())).deInit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsHook),
            "::",
            stringify!(deInit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsHook>())).mallocMark as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsHook),
            "::",
            stringify!(mallocMark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsHook>())).freeMark as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsHook),
            "::",
            stringify!(freeMark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsHook>())).simpleMark as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsHook),
            "::",
            stringify!(simpleMark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LmsHook>())).check as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LmsHook),
            "::",
            stringify!(check)
        )
    );
}
extern "C" {
    pub static mut g_lms: *mut LmsHook;
}
extern "C" {
    pub fn OsLmsInit();
}
extern "C" {
    pub fn OsLmsCheckValid(checkAddr: UINTPTR, isFreeCheck: BOOL);
}
extern "C" {
    pub fn OsLmsLosMallocMark(
        curNodeStart: *const ::std::os::raw::c_void,
        nextNodeStart: *const ::std::os::raw::c_void,
        nodeHeadSize: UINT32,
    );
}
extern "C" {
    pub fn OsLmsLosFreeMark(
        curNodeStart: *const ::std::os::raw::c_void,
        nextNodeStart: *const ::std::os::raw::c_void,
        nodeHeadSize: UINT32,
    );
}
extern "C" {
    pub fn OsLmsSimpleMark(startAddr: UINTPTR, endAddr: UINTPTR, value: UINT32);
}
extern "C" {
    pub fn OsLmsPrintPoolListInfo();
}
extern "C" {
    pub fn OsLmsReportError(p: UINTPTR, size: UINT32, errMod: UINT32);
}
extern "C" {
    pub fn CheckValid(dest: *const CHAR, src: *const CHAR);
}
extern "C" {
    pub fn __asan_store1_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_store4_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_load4_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_load1_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_loadN_noabort(p: UINTPTR, size: UINT32);
}
extern "C" {
    pub fn __asan_storeN_noabort(p: UINTPTR, size: UINT32);
}
extern "C" {
    pub fn __asan_store2_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_load2_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_store8_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_load8_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_load16_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_store16_noabort(p: UINTPTR);
}
extern "C" {
    pub fn __asan_handle_no_return();
}
