/* automatically generated by rust-bindgen 0.59.1 */
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]

pub const OS_LITTLE_ENDIAN: u32 = 4660;
pub const OS_BIG_ENDIAN: u32 = 17185;
pub const OS_BYTE_ORDER: u32 = 4660;
pub const LOS_OK: u32 = 0;
pub const OS_FAIL: u32 = 1;
pub const OS_64BIT_MAX: i32 = -1;
pub const __LIBATOMIC_N_LOCKS: u32 = 16;
pub const OS_SYS_CLOCK: u32 = 1000000;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND: u32 = 100;
pub const LOSCFG_BASE_CORE_TICK_PER_SECOND_MINI: u32 = 1000;
pub const LOSCFG_BASE_CORE_TICK_PERIOD_MS: u32 = 10;
pub const LOSCFG_BASE_CORE_TICK_WTIMER: u32 = 0;
pub const LOSCFG_BASE_CORE_TICK_RESPONSE_MAX: u32 = 0;
pub const LOSCFG_PLATFORM_HWI: u32 = 1;
pub const LOSCFG_USE_SYSTEM_DEFINED_INTERRUPT: u32 = 1;
pub const LOSCFG_PLATFORM_HWI_LIMIT: u32 = 32;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_PRIO: u32 = 10;
pub const LOSCFG_BASE_CORE_TSK_LIMIT: u32 = 5;
pub const LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE: u32 = 384;
pub const LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE: u32 = 1024;
pub const LOSCFG_BASE_CORE_TIMESLICE: u32 = 1;
pub const LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT: u32 = 20000;
pub const LOSCFG_BASE_CORE_TSK_MONITOR: u32 = 0;
pub const LOSCFG_BASE_CORE_EXC_TSK_SWITCH: u32 = 0;
pub const LOS_TASK_PRIORITY_HIGHEST: u32 = 0;
pub const LOS_TASK_PRIORITY_LOWEST: u32 = 31;
pub const LOSCFG_BASE_CORE_TASKSTACK_INDEPENDENT: u32 = 0;
pub const LOSCFG_STACK_POINT_ALIGN_SIZE: u32 = 8;
pub const LOSCFG_BASE_IPC_SEM: u32 = 1;
pub const LOSCFG_BASE_IPC_SEM_LIMIT: u32 = 6;
pub const OS_SEM_COUNTING_MAX_COUNT: u32 = 65535;
pub const LOSCFG_BASE_IPC_MUX: u32 = 1;
pub const LOSCFG_BASE_IPC_MUX_LIMIT: u32 = 6;
pub const LOSCFG_BASE_IPC_QUEUE: u32 = 1;
pub const LOSCFG_BASE_IPC_QUEUE_LIMIT: u32 = 6;
pub const LOSCFG_BASE_IPC_STATIC_QUEUE_LIMIT: u32 = 3;
pub const LOSCFG_BASE_CORE_SWTMR: u32 = 1;
pub const LOSCFG_BASE_CORE_SWTMR_LIMIT: u32 = 5;
pub const LOSCFG_BASE_CORE_TSK_SWTMR_STACK_SIZE: u32 = 1024;
pub const LOSCFG_BASE_CORE_SWTMR_ALIGN: u32 = 0;
pub const OS_SWTMR_HANDLE_QUEUE_SIZE: u32 = 5;
pub const LOS_COMMON_DIVISOR: u32 = 10;
pub const LOSCFG_SYS_EXTERNAL_HEAP: u32 = 0;
pub const LOSCFG_SYS_HEAP_SIZE: u32 = 65536;
pub const LOSCFG_MEM_MUL_POOL: u32 = 1;
pub const LOSCFG_MEM_FREE_BY_TASKID: u32 = 0;
pub const LOSCFG_BASE_MEM_NODE_INTEGRITY_CHECK: u32 = 0;
pub const LOSCFG_MEM_OMIT_LR_CNT: u32 = 4;
pub const LOSCFG_MEM_RECORD_LR_CNT: u32 = 3;
pub const LOSCFG_MEM_LEAKCHECK_RECORD_MAX_NUM: u32 = 1024;
pub const LOSCFG_MEM_WATERLINE: u32 = 1;
pub const OS_SYS_MEM_NUM: u32 = 20;
pub const OS_SYS_NOCACHEMEM_SIZE: u32 = 0;
pub const LOSCFG_MEM_MUL_REGIONS: u32 = 0;
pub const LOSCFG_EXC_HARDWARE_STACK_PROTECTION: u32 = 0;
pub const CMSIS_OS_VER: u32 = 2;
pub const LOSCFG_KERNEL_PRINTF: u32 = 1;
pub const LOSCFG_MPU_ENABLE: u32 = 0;
pub const LOSCFG_TASK_MEM_USED: u32 = 0;
pub const LOSCFG_PLATFORM_HWI_WITH_ARG: u32 = 0;
pub const LOSCFG_ARCH_HWI_VECTOR_ALIGN: u32 = 256;
pub const LOSCFG_KERNEL_SIGNAL: u32 = 0;
pub const LOSCFG_KERNEL_PM: u32 = 0;
pub const LOSCFG_KERNEL_PM_IDLE: u32 = 0;
pub const LOSCFG_SHELL_STACK_SIZE: u32 = 4096;
pub const OS_ERR_MAGIC_WORD: u32 = 2712847352;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type INT8 = ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type FLOAT = f32;
pub type DOUBLE = f64;
pub type CHAR = ::std::os::raw::c_char;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type INT64 = ::std::os::raw::c_longlong;
pub type UINTPTR = ::std::os::raw::c_uint;
pub type INTPTR = ::std::os::raw::c_int;
pub type Atomic = INT32;
pub type Atomic64 = INT64;
pub type BOOL = ::std::os::raw::c_uint;
extern "C" {
    pub static mut m_aucSysMem0: *mut UINT8;
}
#[doc = " @ingroup los_list"]
#[doc = " Structure of a node in a doubly linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOS_DL_LIST {
    #[doc = "< Current node's pointer to the previous node"]
    pub pstPrev: *mut LOS_DL_LIST,
    #[doc = "< Current node's pointer to the next node"]
    pub pstNext: *mut LOS_DL_LIST,
}
#[test]
fn bindgen_test_layout_LOS_DL_LIST() {
    assert_eq!(
        ::std::mem::size_of::<LOS_DL_LIST>(),
        16usize,
        concat!("Size of: ", stringify!(LOS_DL_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<LOS_DL_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(LOS_DL_LIST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_DL_LIST>())).pstPrev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_DL_LIST),
            "::",
            stringify!(pstPrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LOS_DL_LIST>())).pstNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LOS_DL_LIST),
            "::",
            stringify!(pstNext)
        )
    );
}
#[doc = " @ingroup los_err"]
#[doc = " @brief Define the pointer to the error handling function."]
#[doc = ""]
#[doc = " @par Description:"]
#[doc = " This API is used to define the pointer to the error handling function."]
#[doc = " @attention"]
#[doc = " <ul>"]
#[doc = " <li>None.</li>"]
#[doc = " </ul>"]
#[doc = ""]
#[doc = " @param  fileName  [IN] Log file that stores error information."]
#[doc = " @param  lineNo    [IN] Line number of the erroneous line."]
#[doc = " @param  errorNo   [IN] Error code."]
#[doc = " @param  paraLen   [IN] Length of the input parameter pPara."]
#[doc = " @param  para      [IN] User label of the error."]
#[doc = ""]
#[doc = " @retval None."]
#[doc = " @par Dependency:"]
#[doc = " <ul><li>los_err.h: the header file that contains the API declaration.</li></ul>"]
#[doc = " @see None."]
pub type LOS_ERRORHANDLE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        fileName: *mut CHAR,
        lineNo: UINT32,
        errorNo: UINT32,
        paraLen: UINT32,
        para: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @ingroup los_err"]
    #[doc = " @brief Error handling function."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to perform different operations according to error types."]
    #[doc = " @attention"]
    #[doc = " <ul>"]
    #[doc = " <li>None</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param  fileName  [IN] Log file that stores error information."]
    #[doc = " @param  lineNo    [IN] Line number of the erroneous line which should not be OS_ERR_MAGIC_WORD."]
    #[doc = " @param  errorNo   [IN] Error code."]
    #[doc = " @param  paraLen   [IN] Length of the input parameter pPara."]
    #[doc = " @param  para      [IN] User label of the error."]
    #[doc = ""]
    #[doc = " @retval LOS_OK The error is successfully processed."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_err.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see None"]
    pub fn LOS_ErrHandle(
        fileName: *mut CHAR,
        lineNo: UINT32,
        errorNo: UINT32,
        paraLen: UINT32,
        para: *mut ::std::os::raw::c_void,
    ) -> UINT32;
}
#[doc = " @ingroup los_err"]
#[doc = " Error handling function structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagUserErrFunc {
    #[doc = "< Hook function for error handling."]
    pub pfnHook: LOS_ERRORHANDLE_FUNC,
}
#[test]
fn bindgen_test_layout_tagUserErrFunc() {
    assert_eq!(
        ::std::mem::size_of::<tagUserErrFunc>(),
        8usize,
        concat!("Size of: ", stringify!(tagUserErrFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<tagUserErrFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(tagUserErrFunc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagUserErrFunc>())).pfnHook as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagUserErrFunc),
            "::",
            stringify!(pfnHook)
        )
    );
}
#[doc = " @ingroup los_err"]
#[doc = " Error handling function structure."]
pub type UserErrFunc = tagUserErrFunc;
pub const LOS_MODULE_ID_LOS_MOD_SYS: LOS_MODULE_ID = 0;
pub const LOS_MODULE_ID_LOS_MOD_MEM: LOS_MODULE_ID = 1;
pub const LOS_MODULE_ID_LOS_MOD_TSK: LOS_MODULE_ID = 2;
pub const LOS_MODULE_ID_LOS_MOD_SWTMR: LOS_MODULE_ID = 3;
pub const LOS_MODULE_ID_LOS_MOD_TICK: LOS_MODULE_ID = 4;
pub const LOS_MODULE_ID_LOS_MOD_MSG: LOS_MODULE_ID = 5;
pub const LOS_MODULE_ID_LOS_MOD_QUE: LOS_MODULE_ID = 6;
pub const LOS_MODULE_ID_LOS_MOD_SEM: LOS_MODULE_ID = 7;
pub const LOS_MODULE_ID_LOS_MOD_MBOX: LOS_MODULE_ID = 8;
pub const LOS_MODULE_ID_LOS_MOD_HWI: LOS_MODULE_ID = 9;
pub const LOS_MODULE_ID_LOS_MOD_HWWDG: LOS_MODULE_ID = 10;
pub const LOS_MODULE_ID_LOS_MOD_CACHE: LOS_MODULE_ID = 11;
pub const LOS_MODULE_ID_LOS_MOD_HWTMR: LOS_MODULE_ID = 12;
pub const LOS_MODULE_ID_LOS_MOD_MMU: LOS_MODULE_ID = 13;
pub const LOS_MODULE_ID_LOS_MOD_LOG: LOS_MODULE_ID = 14;
pub const LOS_MODULE_ID_LOS_MOD_ERR: LOS_MODULE_ID = 15;
pub const LOS_MODULE_ID_LOS_MOD_EXC: LOS_MODULE_ID = 16;
pub const LOS_MODULE_ID_LOS_MOD_CSTK: LOS_MODULE_ID = 17;
pub const LOS_MODULE_ID_LOS_MOD_MPU: LOS_MODULE_ID = 18;
pub const LOS_MODULE_ID_LOS_MOD_NMHWI: LOS_MODULE_ID = 19;
pub const LOS_MODULE_ID_LOS_MOD_TRACE: LOS_MODULE_ID = 20;
pub const LOS_MODULE_ID_LOS_MOD_IPC: LOS_MODULE_ID = 24;
pub const LOS_MODULE_ID_LOS_MOD_TIMER: LOS_MODULE_ID = 26;
pub const LOS_MODULE_ID_LOS_MOD_EVENT: LOS_MODULE_ID = 28;
pub const LOS_MODULE_ID_LOS_MOD_MUX: LOS_MODULE_ID = 29;
pub const LOS_MODULE_ID_LOS_MOD_CPUP: LOS_MODULE_ID = 30;
pub const LOS_MODULE_ID_LOS_MOD_HOOK: LOS_MODULE_ID = 31;
pub const LOS_MODULE_ID_LOS_MOD_PM: LOS_MODULE_ID = 32;
pub const LOS_MODULE_ID_LOS_MOD_LMK: LOS_MODULE_ID = 33;
pub const LOS_MODULE_ID_LOS_MOD_SHELL: LOS_MODULE_ID = 49;
pub const LOS_MODULE_ID_LOS_MOD_SIGNAL: LOS_MODULE_ID = 50;
pub const LOS_MODULE_ID_LOS_MOD_BUTT: LOS_MODULE_ID = 51;
pub type LOS_MODULE_ID = ::std::os::raw::c_uint;
pub type FreeMemByKillingTask = ::std::option::Option<unsafe extern "C" fn() -> UINT32>;
pub type RestoreKilledTask = ::std::option::Option<unsafe extern "C" fn() -> UINT32>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LosLmkOpsNode {
    #[doc = "< The priority in the LMK list, the higher priority with a smaller number."]
    pub priority: UINT32,
    #[doc = "< Release the memory of tasks in the LMK list. Return LOS_OK for a successful release."]
    pub freeMem: ::std::option::Option<unsafe extern "C" fn() -> UINT32>,
    #[doc = "< Restore the tasks killed by freeMem(). Return LOS_OK for a successful restore."]
    pub restoreTask: ::std::option::Option<unsafe extern "C" fn() -> UINT32>,
    #[doc = "< LosLmkOpsNode node."]
    pub node: LOS_DL_LIST,
}
#[test]
fn bindgen_test_layout_LosLmkOpsNode() {
    assert_eq!(
        ::std::mem::size_of::<LosLmkOpsNode>(),
        40usize,
        concat!("Size of: ", stringify!(LosLmkOpsNode))
    );
    assert_eq!(
        ::std::mem::align_of::<LosLmkOpsNode>(),
        8usize,
        concat!("Alignment of ", stringify!(LosLmkOpsNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosLmkOpsNode>())).priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LosLmkOpsNode),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosLmkOpsNode>())).freeMem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LosLmkOpsNode),
            "::",
            stringify!(freeMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosLmkOpsNode>())).restoreTask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LosLmkOpsNode),
            "::",
            stringify!(restoreTask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosLmkOpsNode>())).node as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LosLmkOpsNode),
            "::",
            stringify!(node)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LosLmkOps {
    #[doc = "< The registered LosLmkOpsNode will be inserted in this list."]
    pub lmkOpsList: LOS_DL_LIST,
    #[doc = "< Flag that if LOS_LmkTasksKill has been invoked."]
    pub isMemFreed: BOOL,
}
#[test]
fn bindgen_test_layout_LosLmkOps() {
    assert_eq!(
        ::std::mem::size_of::<LosLmkOps>(),
        24usize,
        concat!("Size of: ", stringify!(LosLmkOps))
    );
    assert_eq!(
        ::std::mem::align_of::<LosLmkOps>(),
        8usize,
        concat!("Alignment of ", stringify!(LosLmkOps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosLmkOps>())).lmkOpsList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LosLmkOps),
            "::",
            stringify!(lmkOpsList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LosLmkOps>())).isMemFreed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LosLmkOps),
            "::",
            stringify!(isMemFreed)
        )
    );
}
extern "C" {
    #[doc = " @ingroup los_lmk"]
    #[doc = " @brief Register a low memory killer node."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to register a low memory killer node. A LosLmkOpsNode node"]
    #[doc = " can be registered only once."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param  lmkNode [IN] The LosLmkOpsNode node to be registered."]
    #[doc = ""]
    #[doc = " @retval LOS_OK The LosLmkOpsNode node is registered successfully."]
    #[doc = " @retval LOS_ERRNO_LMK_INVALID_PARAMETER  The parameter is invalid."]
    #[doc = " @retval LOS_ERRNO_LMK_ALREADY_REGISTERED The LosLmkOpsNode node already registered."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_lmk.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_LmkOpsNodeRegister(lmkNode: *mut LosLmkOpsNode) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_lmk"]
    #[doc = " @brief Unregister a low memory killer node."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to unregister a low memory killer node."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param  lmkNode [IN] The LosLmkOpsNode node to be registered."]
    #[doc = ""]
    #[doc = " @retval LOS_OK The LosLmkOpsNode node is unregistered successfully."]
    #[doc = " @retval LOS_ERRNO_LMK_NOT_REGISTERED The LosLmkOpsNode node is not yet registered."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_lmk.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_LmkOpsNodeUnregister(lmkNode: *mut LosLmkOpsNode) -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_lmk"]
    #[doc = " @brief Initialize low memory killer framework."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to initialize the low memory killer framework."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval None."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_lmk.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn OsLmkInit();
}
extern "C" {
    #[doc = " @ingroup los_lmk"]
    #[doc = " @brief Restore the tasks killed by the task which triggers low memory killer."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = " This API is used to restore the tasks killed by the task which triggers low memory killer."]
    #[doc = " This function will be invoked by the developer as needed."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval LOS_OK  All the restore killed tasks functions are invoked successfully."]
    #[doc = " @retval LOS_ERRNO_LMK_RESTORE_NOT_NEEDED No need to restore since no tasks killed to free memory."]
    #[doc = " @retval LOS_ERRNO_LMK_RESTORE_TASKS_FAILURE Failed to restore the killed tasks by invoking the registered functions."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_lmk.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_LmkTasksRestore() -> UINT32;
}
extern "C" {
    #[doc = " @ingroup los_lmk"]
    #[doc = " @brief Kill the tasks to release the used memory."]
    #[doc = ""]
    #[doc = " @par Description:"]
    #[doc = "  This API is used to kill the tasks to release the used memory when low memory killer is triggered."]
    #[doc = ""]
    #[doc = " @attention None."]
    #[doc = ""]
    #[doc = " @param  None."]
    #[doc = ""]
    #[doc = " @retval LOS_OK All the free memory functions are invoked successfully."]
    #[doc = " @retval LOS_ERRNO_LMK_MEMORY_ALREADY_FREED The registered free memory functions have been invoked."]
    #[doc = " @retval LOS_ERRNO_LMK_FREE_MEMORY_FAILURE Failed to free memory by invoking the registered functions."]
    #[doc = " @par Dependency:"]
    #[doc = " <ul><li>los_lmk.h: the header file that contains the API declaration.</li></ul>"]
    #[doc = " @see"]
    pub fn LOS_LmkTasksKill() -> UINT32;
}
